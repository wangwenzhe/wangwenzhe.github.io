<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java全栈-上 | 王文哲的博客</title><meta name="author" content="王文哲"><meta name="copyright" content="王文哲"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 基础语法基础面向对象特性 封装：将数据和业务逻辑细节封装到类中，对外提供一些方法。1. 简化操作 2. 保护数据 3. 可复用性 继承：类是单继承，接口支持多继承。父类引用指向子类对象称为 向上转型 多态：编译时多态和运行时多态。编译时多态就是方法的重载：方法名一样，但参数不一致。运行时多态就是在运行期间才确定具体对象类型，三个条件：继承、重写、向上转型  访问修饰符 用来控制类、变量、">
<meta property="og:type" content="article">
<meta property="og:title" content="Java全栈-上">
<meta property="og:url" content="https://wangwenzhe.github.io/posts/6ae47d17.html">
<meta property="og:site_name" content="王文哲的博客">
<meta property="og:description" content="Java 基础语法基础面向对象特性 封装：将数据和业务逻辑细节封装到类中，对外提供一些方法。1. 简化操作 2. 保护数据 3. 可复用性 继承：类是单继承，接口支持多继承。父类引用指向子类对象称为 向上转型 多态：编译时多态和运行时多态。编译时多态就是方法的重载：方法名一样，但参数不一致。运行时多态就是在运行期间才确定具体对象类型，三个条件：继承、重写、向上转型  访问修饰符 用来控制类、变量、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wangwenzhe.github.io/about/logo.png">
<meta property="article:published_time" content="2024-07-01T22:36:31.000Z">
<meta property="article:modified_time" content="2025-06-15T13:17:21.733Z">
<meta property="article:author" content="王文哲">
<meta property="article:tag" content="Java全栈">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wangwenzhe.github.io/about/logo.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wangwenzhe.github.io/posts/6ae47d17.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java全栈-上',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-15 21:17:21'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/about/logo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">588</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">351</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">549</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/img/top_img.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="王文哲的博客"><span class="site-name">王文哲的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java全栈-上</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-01T22:36:31.000Z" title="发表于 2024-07-02 06:36:31">2024-07-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-15T13:17:21.733Z" title="更新于 2025-06-15 21:17:21">2025-06-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%85%A8%E6%A0%88/">Java全栈</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">39.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>122分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java全栈-上"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h3 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h3><h4 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h4><ul>
<li>封装：将数据和业务逻辑细节封装到类中，对外提供一些方法。1. 简化操作 2. 保护数据 3. 可复用性</li>
<li>继承：类是单继承，接口支持多继承。父类引用指向子类对象称为 <strong>向上转型</strong></li>
<li>多态：编译时多态和运行时多态。编译时多态就是方法的重载：方法名一样，但参数不一致。运行时多态就是在运行期间才确定具体对象类型，三个条件：继承、重写、向上转型</li>
</ul>
<h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><blockquote>
<p>用来控制类、变量、方法和构造函数的可见性和访问权限</p>
</blockquote>
<ul>
<li>public：都可以访问</li>
<li>protect：同包和子类中可以访问</li>
<li>无修饰符：同一个包内的类可以访问</li>
<li>private：仅在类内部可以访问</li>
</ul>
<h4 id="如何理解private所修饰的方法是隐式的final"><a href="#如何理解private所修饰的方法是隐式的final" class="headerlink" title="如何理解private所修饰的方法是隐式的final"></a>如何理解private所修饰的方法是隐式的final</h4><p>private 修饰的方法，子类无法继承，更不能重写，所以可以看成是 final 的</p>
<h4 id="final-类如何拓展"><a href="#final-类如何拓展" class="headerlink" title="final 类如何拓展?"></a>final 类如何拓展?</h4><p>final 类无法被继承，但可以使用<strong>外观模式</strong>进行拓展</p>
<h4 id="final方法可以被重载吗"><a href="#final方法可以被重载吗" class="headerlink" title="final方法可以被重载吗?"></a>final方法可以被重载吗?</h4><p>父类的final方法是不能够被子类重写的，那么final方法可以被重载吗? 答案是可以的，也就是编译时多态</p>
<h4 id="Java-内存模型-JMM"><a href="#Java-内存模型-JMM" class="headerlink" title="Java 内存模型 JMM"></a>Java 内存模型 JMM</h4><p>Java内存模型（Java Memory Model, JMM）将内存分为<strong>主内存</strong>和<strong>工作内存</strong>。主内存是所有线程共享的（对应 Java堆内存和方法区&#x2F;元空间），而每个线程有自己的工作内存（虚拟机栈、本地方法栈、程序计数器）</p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><ul>
<li><p>保证数据在多线程中的<strong>可见性</strong></p>
</li>
<li><p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主内存，当有其他线程需要读取时，它会去主内存中读取新值</p>
</li>
<li><p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
</li>
</ul>
<h4 id="volatile是如何实现可见性的"><a href="#volatile是如何实现可见性的" class="headerlink" title="volatile是如何实现可见性的?"></a>volatile是如何实现可见性的?</h4><p>内存屏障</p>
<h4 id="volatile能保证原子性吗"><a href="#volatile能保证原子性吗" class="headerlink" title="volatile能保证原子性吗?"></a>volatile能保证原子性吗?</h4><p>不能完全保证，只能保证单次的读&#x2F;写操作具有原子性</p>
<h4 id="a-a-b-与-a-b-的区别"><a href="#a-a-b-与-a-b-的区别" class="headerlink" title="a &#x3D; a + b 与 a +&#x3D; b 的区别"></a>a &#x3D; a + b 与 a +&#x3D; b 的区别</h4><ul>
<li><p>+&#x3D; 隐式的将加操作的结果类型强制转换为持有结果的类型。</p>
</li>
<li><p>如果两个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。</p>
</li>
</ul>
<h4 id="3-0-1-0-3-将会返回什么-true-还是-false"><a href="#3-0-1-0-3-将会返回什么-true-还是-false" class="headerlink" title="3*0.1 &#x3D;&#x3D; 0.3 将会返回什么? true 还是 false?"></a>3*0.1 &#x3D;&#x3D; 0.3 将会返回什么? true 还是 false?</h4><p>false，因为有些浮点数不能完全精确的表示出来。</p>
<h4 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h4><p>整数部分：除2 取余，商不为0，继续除 2 取余，倒序排列</p>
<p>小数部分：乘 2 取整，结果的小数部分继续乘 2 取整，直到达到所需的精度或发现循环，顺序排列</p>
<h4 id="单精度浮点数存储"><a href="#单精度浮点数存储" class="headerlink" title="单精度浮点数存储"></a>单精度浮点数存储</h4><p>32 位，由三部分组成：符号位（S）、指数位（E）和尾数位（M或F）。</p>
<ol>
<li><strong>符号位（S）</strong>：1位，用来表示数的正负。0代表正数，1代表负数。对于3.14，它是正数，所以符号位是0。</li>
<li><strong>指数位（E）</strong>：8位，用于存储指数部分，但实际存储的是偏置后的值。在单精度浮点数中，指数值会加上一个固定的偏置量（127）。这样做的目的是为了能够表示负指数（通过存储一个小于127的值）。</li>
<li><strong>尾数位（M）</strong>：23位，存储有效数字的小数部分。在实际存储中，会默认在最前面有一个隐含的1（即所谓的隐藏位），因此实际上可以表示24位精度。</li>
</ol>
<h4 id="能在-Switch-中使用-String-吗"><a href="#能在-Switch-中使用-String-吗" class="headerlink" title="能在 Switch 中使用 String 吗?"></a>能在 Switch 中使用 String 吗?</h4><p>从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code</p>
<h4 id="对equals-和hashCode-的理解"><a href="#对equals-和hashCode-的理解" class="headerlink" title="对equals()和hashCode()的理解?"></a>对equals()和hashCode()的理解?</h4><ul>
<li><strong>为什么在重写 equals 方法的时候需要重写 hashCode 方法</strong>?</li>
</ul>
<p>因为有强制的规范指定需要同时重写 hashcode 与 equals 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。</p>
<ul>
<li><strong>有没有可能两个不相等的对象有相同的 hashcode</strong>?</li>
</ul>
<p>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。</p>
<ul>
<li><strong>两个相同的对象会有不同的 hash code 吗</strong>?</li>
</ul>
<p>不能，根据 hash code 的规定，这是不可能的。</p>
<h4 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h4><p>Java 7引入的一种声明式语法 <code>try () &#123;&#125;</code>，用于自动管理资源，确保在代码块执行完毕后即使遇到异常也能正确关闭资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源文件路径</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sourceFilePath</span> <span class="operator">=</span> <span class="string">&quot;source.txt&quot;</span>;</span><br><span class="line"><span class="comment">// 目标文件路径</span></span><br><span class="line"><span class="type">String</span> <span class="variable">targetFilePath</span> <span class="operator">=</span> <span class="string">&quot;target.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourceFilePath);</span><br><span class="line">     <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFilePath)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="type">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((bytesRead = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    fos.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;文件复制完成。&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  System.err.println(<span class="string">&quot;文件复制过程中发生错误: &quot;</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="final、finalize-和-finally-的不同之处"><a href="#final、finalize-和-finally-的不同之处" class="headerlink" title="final、finalize 和 finally 的不同之处"></a>final、finalize 和 finally 的不同之处</h4><ul>
<li>final 是一个修饰符，可以修饰类-不可被继承、成员变量-只读、方法-不可重写。</li>
<li>Java 中一个对象生命周期相关的方法（<code>Object</code> 类的一个保护方法）。在 Java编程实践中，避免使用 <code>finalize()</code></li>
<li>finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。推荐使用<code>try-with-resources</code> 语法结构</li>
</ul>
<h4 id="编译期final常量和非编译期final常量"><a href="#编译期final常量和非编译期final常量" class="headerlink" title="编译期final常量和非编译期final常量"></a>编译期final常量和非编译期final常量</h4><ul>
<li>编译期final常量：声明时初始化，初始化的表达式是一个基本类型或String类型</li>
<li>非编译期final常量：初始化的表达式不是编译期可知的（例如运行时计算的结果），那么这个字段就不是编译期常量。虽然它仍然是不可变的（一旦初始化完成就不能再改变）</li>
</ul>
<h4 id="String、StringBuffer与StringBuilder的区别？"><a href="#String、StringBuffer与StringBuilder的区别？" class="headerlink" title="String、StringBuffer与StringBuilder的区别？"></a>String、StringBuffer与StringBuilder的区别？</h4><ul>
<li><p>可变性。String对象是不可变的，而StringBuffer和StringBuilder是可变字符序列。每次对String的操作相当于生成一个新的String对象，而对StringBuffer和StringBuilder的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用String，因为频繁的生成对象将会对系统性能产生影响。</p>
</li>
<li><p>线程安全性。String由于有final修饰，是immutable的，安全性是简单而纯粹的。StringBuilder和StringBuffer的区别在于StringBuilder不保证同步，也就是说如果需要线程安全需要使用StringBuffer，不需要同步的StringBuilder效率更高。</p>
</li>
</ul>
<h4 id="接口与抽象类的区别？"><a href="#接口与抽象类的区别？" class="headerlink" title="接口与抽象类的区别？"></a>接口与抽象类的区别？</h4><ul>
<li>一个子类只能继承一个抽象类, 但能实现多个接口</li>
<li>抽象类可以有构造方法, 接口没有构造方法</li>
<li>抽象类可以有普通成员变量, 接口没有普通成员变量</li>
<li>抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能public static final(默认)</li>
<li>抽象类可以没有抽象方法, 抽象类可以有普通方法；<strong>接口在JDK8之前都是抽象方法，在JDK8可以有default方法</strong>，在JDK9中允许有私有普通方法</li>
<li>抽象类可以有静态方法；接口在JDK8之前不能有静态方法，在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）</li>
<li>抽象类中的方法可以是public、protected; 接口方法在JDK8之前只有public abstract，在JDK8可以有default方法，在JDK9中允许有private方法</li>
</ul>
<h4 id="this-和-super-在构造方法中的区别"><a href="#this-和-super-在构造方法中的区别" class="headerlink" title="this() 和 super()在构造方法中的区别"></a>this() 和 super()在构造方法中的区别</h4><ul>
<li>调用super()必须写在子类构造方法的第一行, 否则编译不通过</li>
<li>super从子类调用父类构造, this在同一类中调用其他构造均需要放在第一行</li>
<li>尽管可以用this调用一个构造器, 却不能调用2个</li>
<li>this和super不能出现在同一个构造器中, 否则编译不通过</li>
<li>this()、super()都指的对象,不可以在static环境中使用</li>
<li>本质this指向本对象的指针。super是一个关键字</li>
</ul>
<h4 id="Java移位运算符？"><a href="#Java移位运算符？" class="headerlink" title="Java移位运算符？"></a>Java移位运算符？</h4><p>java中有三种移位运算符</p>
<ul>
<li><code>&lt;&lt;</code> :左移运算符,<code>x &lt;&lt; 1</code>,相当于x乘以2(不溢出的情况下),低位补0</li>
<li><code>&gt;&gt;</code> :带符号右移,<code>x &gt;&gt; 1</code>,相当于x除以2,正数高位补0,负数高位补1</li>
<li><code>&gt;&gt;&gt;</code> :无符号右移,忽略符号位,空位都以0补齐</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li>在类、接口和方法中使用泛型，实现<strong>类型的参数化</strong></li>
<li><strong>重用性（代码更简洁）</strong>、<strong>类型安全性（编译期间检查、转换，避免了强制类型转换）</strong></li>
<li>泛型上下限<ul>
<li>帮助开发者更精确地控制类型范围，提高代码的灵活性和安全性</li>
<li>泛型上限：使用<code>extends</code>关键字来指定其上限，意味着该类型参数必须是指定类型或者其子类型</li>
<li>泛型下限：使用<code>super</code>关键字来指定其下限，意味着该类型参数必须是指定类型或者其超类型</li>
</ul>
</li>
<li>通配符（未知类型，不关注类型 T，修饰方法形参中类型）<ul>
<li><?> 无边界的通配符。匹配任何类型</li>
<li><? extends T> ：实参类为 T及其子类</li>
<li><? super T>  ：实参类为 T及其超类</li>
</ul>
</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul>
<li><p>注解（Annotation）是一种元数据，它可以为程序元素（如类、方法、变量等）提供附加信息。注解被编译器、开发工具或运行时环境生成其他代码、进行验证或执行某些处理。</p>
</li>
<li><p>内置注解有<code>@Override</code>, <code>@Deprecated</code>, <code>@SuppressWarnings</code>等，同时开发者也可以自定义注解。自定义注解通过使用<code>@interface</code>关键字实现，并可以指定元注解（如<code>@Retention</code>, <code>@Target</code>, <code>@Documented</code>, <code>@Inherited</code>）来控制注解的生命周期、适用范围、是否包含在文档中以及是否可被子类继承等特性。</p>
</li>
<li><p>作用：</p>
<ul>
<li>生成文档，通过代码里标识的元数据生成javadoc文档</li>
<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证</li>
<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码</li>
<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例</li>
</ul>
</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="Java异常类层次结构"><a href="#Java异常类层次结构" class="headerlink" title="Java异常类层次结构?"></a>Java异常类层次结构?</h4><ul>
<li><strong>Throwable</strong> 是 Java 语言中所有错误与异常的超类。 </li>
<li><strong>Error</strong> 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</li>
<li><strong>Exception</strong> 程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常</li>
<li>运行时异常：运行期间产生的异常，例如空指针异常、下标越界访问异常等</li>
<li>编译时异常：在编译期间产生的异常，不处理，编译通不过，例如 IOException、SQLException、用户自定义的Exception异常</li>
</ul>
<h4 id="可查的异常和不可查的异常区别？"><a href="#可查的异常和不可查的异常区别？" class="headerlink" title="可查的异常和不可查的异常区别？"></a>可查的异常和不可查的异常区别？</h4><ul>
<li><strong>可查异常</strong>（编译器要求必须处置的异常）。除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常</li>
<li><strong>不可查异常</strong>(编译器不要求强制处置的异常)：包括运行时异常（RuntimeException与其子类）和错误（Error）</li>
</ul>
<h4 id="throw和throws的区别？"><a href="#throw和throws的区别？" class="headerlink" title="throw和throws的区别？"></a>throw和throws的区别？</h4><ul>
<li>throw： 主动抛出异常实例</li>
<li>throws： 若方法中存在<strong>检查异常</strong>，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 关键字throws，后面是异常类，若声明多种异常，则使用逗号分割</li>
</ul>
<h4 id="异常的底层？-异常表"><a href="#异常的底层？-异常表" class="headerlink" title="异常的底层？ - 异常表"></a>异常的底层？ - 异常表</h4><p>Exception Table，以下称为异常表</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="反射是什么"><a href="#反射是什么" class="headerlink" title="反射是什么"></a>反射是什么</h4><ul>
<li>从镜子中看到自己，这就是反射</li>
<li>class 文件被类加载器加载到 JVM 内存的方法区</li>
<li>通过反射，程序在运行时能够动态地访问和操作类和对象信息</li>
</ul>
<h4 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h4><ul>
<li>动态加载类</li>
<li>获取类信息，包括解析类、方法、字段上的注解信息</li>
<li>实例化对象</li>
<li>调用方法，包括私有方法</li>
<li>访问和修改成员变量的值</li>
</ul>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><ul>
<li>SPI（Service Provider Interface）机制，是Java提供的一种用于<strong>发现和加载实现类</strong>的方式，它允许第三方为一组接口提供自己的实现</li>
<li>SPI主要用于框架扩展，使得框架的设计者在不需要修改代码的情况下就能够引入新的功能模块</li>
<li>原理<ul>
<li><strong>定义接口</strong>：首先，需要定义一个或多个接口，这些接口声明了服务的规范</li>
<li><strong>提供实现类和配置文件</strong>：实现该接口的提供者需要在自己jar包的<code>META-INF/services/</code>目录下创建一个以<strong>接口全限定名命名</strong>的文件。该文件的内容就是这个接口的一个或多个实现类的全限定名，每行一个，如果有多个实现，则可以通过换行分隔</li>
<li><strong>ServiceLoader 服务查找</strong>：当应用程序需要使用这个服务时，可以通过Java的<code>ServiceLoader</code>类来加载这个接口的所有实现。<code>ServiceLoader</code>会查找所有已知的jar包中的<code>META-INF/services/</code>目录下的配置文件，然后依次加载这些文件中指定的实现类，并实例化它们</li>
</ul>
</li>
<li>示例<ul>
<li>JDBC接口定义：首先在java中定义了接口<code>java.sql.Driver</code>，并没有具体的实现，具体的实现都是由不同厂商来提供的。</li>
<li>mysql实现：在mysql的jar包<code>mysql-connector-java-6.0.6.jar</code>中，可以找到<code>META-INF/services</code>目录，该目录下会有一个名字为<code>java.sql.Driver</code>的文件，文件内容是<code>com.mysql.cj.jdbc.Driver</code>，这里面的内容就是针对Java中定义的接口的实现。</li>
</ul>
</li>
</ul>
<h2 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h2><blockquote>
<p>Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。</p>
</blockquote>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul>
<li><code>TreeSet</code> 使用树数据结构（通常是红黑树）来存储元素，当需要一个自动<strong>排序且唯一的</strong>元素的集合时，可以选择该数据结构<ul>
<li><strong>有序</strong>：<strong>默认情况下，元素按照其自然顺序排序</strong>（如果实现了 <code>Comparable</code> 接口），或者可以根据自定义的 <code>Comparator</code> 进行排序</li>
<li><strong>无重复</strong>：不允许有重复的元素</li>
<li><strong>性能</strong>：查找、删除和插入操作的时间复杂度为 O(log n)，其中 n 是集合中的元素数量</li>
<li><strong>迭代器</strong>：迭代器按升序遍历元素</li>
</ul>
</li>
<li><code>HashSet</code> 底层基于 <code>HashMap</code> 实现（数据存储在HashMap的key中，value是PRESENT，一个私有静态final对象），用于存储<strong>无序且唯一</strong>的元素集合，支持快速查找。非线程安全<ul>
<li>用于快速判断某个元素是否属于一个集合，元素去重（无顺序要求）</li>
</ul>
</li>
<li><code>LinkedHashSet</code> 具有 HashSet 的查找效率，且内部使用<strong>双向链表</strong>维护元素的<strong>插入顺序</strong>。非线程安全</li>
<li><code>ConcurrentSkipListSet</code> 可以看作是 <code>TreeSet</code> 并发版本</li>
</ul>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul>
<li><code>ArrayList</code> 基于动态数组实现，支持随机访问，非线程安全<ul>
<li>默认容量为 10</li>
<li>每次扩容 50%，新数组是原来的 1.5 倍。1.5 就是扩容因子</li>
<li>扩容过程：创建新数组，原数组数据拷贝到新数组中，引用指向新数组，原数组被回收（没有引用的话），插入新元素</li>
<li>通过  <code>ensureCapacity</code> 方法手动扩容</li>
</ul>
</li>
<li><code>Vector</code> 和 ArrayList 类似，但它是线程安全的</li>
<li><code>LinkedList</code> 基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>
</ul>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><ul>
<li><code>LinkedList</code> 是基于双向链表实现的，这意味着每个元素（节点）都包含对其前一个元素和后一个元素的引用<ul>
<li>支持双向遍历</li>
<li>插入和删除效率高，但查询效率低</li>
<li>因为实现了 <code>Deque</code> 接口，<code>LinkedList</code> 可以像<strong>栈</strong>一样进行 <code>push</code> 和 <code>pop</code> 操作，像<strong>队列</strong>一样进行 <code>offer</code> 和 <code>poll</code> 操作，以及作为双端队列进行两端的插入和删除操作。</li>
<li><code>LinkedList</code> 对每个元素都需要额外的空间存储前后节点的引用，因此在存储大量简单类型数据时可能会占用更多的内存</li>
</ul>
</li>
<li><strong>PriorityQueue 基于堆结构实现，可以用它来实现优先队列</strong><ul>
<li><strong>排序</strong>: 元素在队列中的位置由它们的优先级决定。默认情况下，优先队列中的元素按照其自然顺序排序（如果元素可比较），或者在创建队列时提供一个自定义比较器。</li>
<li><strong>无界</strong>: <code>PriorityQueue</code> 是无界的，意味着它可以增长以容纳任意数量的元素（受限于系统内存）。</li>
<li><strong>非线程安全</strong>: <code>PriorityQueue</code> 类本身不是线程安全的。如果多个线程要同时访问一个优先队列，通常需要外部同步。</li>
<li><strong>操作</strong>: 主要的操作包括 <code>add(E)</code> 添加元素、<code>poll()</code> 获取并移除队列头部的元素、<code>peek()</code> 查看但不移除队列头部的元素、<code>remove(Object)</code> 移除指定元素等。</li>
<li><strong>内部实现</strong>: <code>PriorityQueue</code> 通常使用二叉堆（通常是小顶堆）来维护元素的有序状态，这样可以保证对 <code>add</code>、<code>remove</code>、<code>peek</code> 等操作的高性能。</li>
</ul>
</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li><code>HashMap</code> 1.8 基于数组+链表+红黑树<ul>
<li>允许null键和null值</li>
<li>不显式指定，初始容量是16（数组的大小）。自定义初始容量，必须是2的幂次方</li>
<li>HashMap内部使用<strong>位运算来计算索引</strong>，这比取模运算更快</li>
<li>默认的<strong>负载因子是0.75</strong>，这意味着当HashMap填充到其容量的75%时，会自动进行扩容。扩容为原来的 2 倍</li>
<li>Key  用来确定位置，最终 key 和 value 都会存储到这个位置上</li>
<li>数组中每个桶的位置存放的有 key、value、链表指针。如果还未存放数据，则放入数据。如果出现哈希冲突，将新键值放入链表后面（链表为空则先创建）。这个链表是单向链表，节点中只存储下一个节点的引用</li>
<li><strong>链表转红黑树</strong>: 当桶中的链表长度超过某个阈值（默认是8）时，该链表会被转换成红黑树。这大大提高了在大量哈希冲突情况下的查找效率，从 O(n) 提升到了 O(log n)</li>
<li><strong>红黑树转链表</strong>: 当桶中红黑树的节点数量降到6以下时，红黑树会退化回链表，因为对于较小的集合，链表的遍历可能更高效。</li>
</ul>
</li>
<li><code>HashTable</code> 和 HashMap 类似，但它是线程安全的，现在不再使用</li>
<li><code>ConcurrentHashMap</code> 支持线程安全，效率比 HashTable 更高</li>
<li><code>LinkedHashMap</code> 使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序</li>
<li><code>TreeMap</code> 基于红黑树实现<ul>
<li><strong>排序</strong>: <code>TreeMap</code> 中的元素是按照 key 的自然顺序（Comparable）或者是通过自定义的比较器（Comparator）进行排序的。这意味着当你遍历 <code>TreeMap</code> 时，会按照 key 的排序顺序来访问元素。</li>
<li><strong>有序映射</strong>: 由于其内部实现为红黑树，<code>TreeMap</code> 提供了对映射的快速访问，特别是对于范围查询（如子 map、从某个键查找更高或更低的键等）非常高效。</li>
<li><strong>操作</strong>: 常用操作包括 <code>put(K key, V value)</code> 插入键值对、<code>get(Object key)</code> 根据键获取值、<code>remove(Object key)</code> 删除键值对、以及多种基于 key 的范围查询方法。</li>
<li><strong>键唯一性</strong>: 和所有 Map 实现一样，<code>TreeMap</code> 中的键必须是唯一的；每个键最多只能对应一个值。</li>
<li><strong>线程不安全</strong>: 和 <code>PriorityQueue</code> 类似，<code>TreeMap</code> 也是非线程安全的。在多线程环境下并发访问和修改时，需要外部同步或使用 <code>ConcurrentSkipListMap</code> 这样的并发集合。</li>
</ul>
</li>
<li><code>ConcurrentSkipListMap</code> 是 <code>TreeMap</code> 的并发版本</li>
</ul>
<h2 id="Java-并发"><a href="#Java-并发" class="headerlink" title="Java 并发"></a>Java 并发</h2><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul>
<li><strong>并发</strong>是任务在宏观上<strong>看起来像是同时</strong>发生，但实际上可能是<strong>交替执行</strong>的。</li>
<li><strong>并行</strong>则是指任务在<strong>物理上同时执行</strong>，这通常需要多处理器或者多核处理器的支持。</li>
</ul>
<h3 id="多线程中数据安全问题"><a href="#多线程中数据安全问题" class="headerlink" title="多线程中数据安全问题"></a>多线程中数据安全问题</h3><h4 id="同步关键字-synchronized"><a href="#同步关键字-synchronized" class="headerlink" title="同步关键字 synchronized"></a>同步关键字 synchronized</h4><ul>
<li>由 Java虚拟机(JVM)实现</li>
<li>它可以用于方法或代码块</li>
<li>非公平锁</li>
<li>它是基于监视器锁（monitor lock）的，对于非静态方法，锁是当前实例对象；对于静态方法，锁是对应的Class对象；对于同步代码块，锁是synchonized括号里配置的对象</li>
<li>同步的方法或代码块中抛出了未被捕获的异常，锁会自动释放</li>
<li>作用域不宜过大，影响程序执行的速度</li>
</ul>
<h4 id="可重入互斥锁-ReentrantLock"><a href="#可重入互斥锁-ReentrantLock" class="headerlink" title="可重入互斥锁 ReentrantLock"></a>可重入互斥锁 ReentrantLock</h4><ul>
<li><p>比 synchronized 更灵活，是Java标准库的一部分</p>
</li>
<li><p>获取锁：lock(); 尝试锁-  tryLock(); 可定时锁- tryLock(long time, TimeUnit unit); 可中断锁lockInterruptibly(); </p>
</li>
<li><p>释放锁：unlock(); 需要手动在finally块中调用unlock()方法来释放锁，以避免死锁</p>
</li>
</ul>
<h4 id="Atomic-原子变量"><a href="#Atomic-原子变量" class="headerlink" title="Atomic 原子变量"></a>Atomic 原子变量</h4><p>如 AtomicInteger、AtomicLong</p>
<h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><ul>
<li><p>volatile 确保了变量的可见性和部分有序性，但不保证原子性。适用于状态标记等简单场景，不适用于复合操作</p>
</li>
<li><p>不可变对象：不可变对象一旦创建就无法改变，因此它们是线程安全的。如<code>String</code>、以及通过final关键字定义且其内部状态不可变的类</p>
</li>
</ul>
<h4 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h4><p>对于<strong>读多写少</strong>的并发场景，可以使用<code>CopyOnWriteArrayList</code>或<code>CopyOnWriteArraySet</code>，这些容器在修改数据时会创建原容器的副本，避免了并发修改异常</p>
<h4 id="并发集合-concurrent"><a href="#并发集合-concurrent" class="headerlink" title="并发集合 concurrent"></a>并发集合 concurrent</h4><p>java.util.concurrent<code>包提供了多种线程安全的集合类，如</code>ConcurrentHashMap、ConcurrentLinkedQueue等，它们通过内部机制实现了高效且线程安全的数据访问</p>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>本地线程变量，保证每个线程中都有一份数据的副本，是独立的。</p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>基于 Redis 实现一个分布式锁</p>
<h3 id="ThreadLocal是如何实现线程隔离的"><a href="#ThreadLocal是如何实现线程隔离的" class="headerlink" title="ThreadLocal是如何实现线程隔离的?"></a>ThreadLocal是如何实现线程隔离的?</h3><p>ThreadLocalMap</p>
<h3 id="方法中局部变量是否存在多线程安全问题？"><a href="#方法中局部变量是否存在多线程安全问题？" class="headerlink" title="方法中局部变量是否存在多线程安全问题？"></a>方法中局部变量是否存在多线程安全问题？</h3><p>不存在。存在于 JVM 栈中，线程之间是隔离的</p>
<h3 id="有哪几种创建线程方式"><a href="#有哪几种创建线程方式" class="headerlink" title="有哪几种创建线程方式?"></a>有哪几种创建线程方式?</h3><p>有三种使用线程的方法:</p>
<ul>
<li>实现 Runnable 接口</li>
<li>实现 Callable 接口</li>
<li>继承 Thread 类</li>
</ul>
<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p>
<h3 id="线程的中断方式有哪些"><a href="#线程的中断方式有哪些" class="headerlink" title="线程的中断方式有哪些?"></a>线程的中断方式有哪些?</h3><ul>
<li>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束</li>
<li>通过调用一个线程的 <code>interrupt()</code> 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞</li>
<li>调用 <code>interrupt()</code> 方法会<strong>设置线程的中断标记</strong>，此时调用 <code>interrupted()</code> 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程</li>
</ul>
<h3 id="多线程顺序控制"><a href="#多线程顺序控制" class="headerlink" title="多线程顺序控制"></a>多线程顺序控制</h3><h4 id="thread-join"><a href="#thread-join" class="headerlink" title="thread.join()"></a>thread.join()</h4><p><code>thread.join()</code>方法可以让一个线程等待另一个线程执行完毕后再继续执行。</p>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><ul>
<li>作用：实现多线程同步控制。例如多个子线程执行各任务，主线程等待所有子线程执行完毕后，再往后执行。</li>
<li><strong>构造方法</strong>：<ul>
<li><code>CountDownLatch(int count)</code>：初始化一个<code>CountDownLatch</code>实例，计数器的初始值为给定的<code>count</code>值。</li>
</ul>
</li>
<li><strong>主要方法</strong>：<ul>
<li><code>await()</code>：调用该方法的线程会被阻塞，直到计数器的值减至0。如果当前计数为0，则该方法立即返回。</li>
<li><code>countDown()</code>：调用该方法会使计数器减1。当计数器达到0时，所有在<code>await()</code>方法处等待的线程都将被释放。</li>
</ul>
</li>
</ul>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>它允许一组线程相互等待，直到到达某个屏障点，所有线程才会继续执行</p>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量，主要用于控制同时访问特定资源的线程数量，但也可以间接用来实现顺序控制</p>
<h4 id="AsycnTool"><a href="#AsycnTool" class="headerlink" title="AsycnTool"></a>AsycnTool</h4><p>解决多线程的并行、串行、阻塞、依赖和回调等问题，还能应对高并发场景下热数据相关的需求</p>
<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="网络上传输的数据是以字符还是字节传输的？"><a href="#网络上传输的数据是以字符还是字节传输的？" class="headerlink" title="网络上传输的数据是以字符还是字节传输的？"></a>网络上传输的数据是以字符还是字节传输的？</h3><p>在网络上传输的数据本质上是以字节（byte）形式进行的。无论是文本、图片、音频还是视频文件</p>
<h3 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h3><p>字节流（Byte Streams）：</p>
<ul>
<li>字节流是最基本的数据传输方式，所有类型的文件在网络传输和磁盘存储时，最终都是以字节形式存在的</li>
<li>因为字节是计算机存储数据的基本单位，所以字节流可以用来处理任何形式的文件，包括二进制文件（如图片、音频、视频）和文本文件</li>
<li><code>InputStream</code>和<code>OutputStream</code>及其子类（如<code>FileInputStream</code>、<code>FileOutputStream</code>）</li>
</ul>
<p>字符流（Character Streams）：</p>
<ul>
<li><strong>字符流是对字节流的封装</strong>，<strong>提供了对文本数据更友好的操作接口</strong>。它内部使用字节流来实现，但对外隐藏了字节处理的细节，让用户可以以字符为单位读写数据。</li>
<li>字符流在读写时会自动进行字符编码和解码，这对于处理文本文件非常有用，可以避免开发者直接处理字节编码的复杂性。</li>
<li><code>Reader</code>和<code>Writer</code>及其子类（如<code>FileReader</code>、<code>FileWriter</code>），它们在内部使用了字节流，并通过指定的字符集进行编码和解码。</li>
</ul>
<p>为什么需要两者：</p>
<ul>
<li>处理文本文件时字符流更为方便</li>
<li>处理图片、音频等二进制数据时则更适合使用字节流</li>
</ul>
<h3 id="Java-IO、NIO、AIO"><a href="#Java-IO、NIO、AIO" class="headerlink" title="Java IO、NIO、AIO"></a>Java IO、NIO、AIO</h3><ul>
<li>传统 Java IO 是面向流的，是阻塞的</li>
</ul>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><ul>
<li>NIO（New I&#x2F;O） 是面向缓冲区的，是非阻塞的</li>
<li>NIO 主要是通过<strong>Selector</strong>和<strong>非阻塞的Channel</strong>来实现<strong>多路复用</strong>的<strong>同步非阻塞I&#x2F;O</strong>，提高了单线程处理多个连接的能力</li>
<li>NIO 引入了选择器Selector、通道Channel、缓冲区Buffer以及非阻塞IO模型，<strong>提高了并发处理能力</strong></li>
<li>选择器Selector：一个线程处理一个Selector，一个Selector支持管理多个通道，Channel需要注册到Selector上，可以监控多个通道的事件（如连接打开、数据可读等）【可以认为选择器需要轮训通道状态】</li>
<li>通道：<ul>
<li><strong>通道是非阻塞的</strong>，也就是从通道读取数据或者写入数据时，即使通道无数据可读或者无法写入，通道也会直接返回结果，而不是让 Selector 阻塞等待，直到数据可读或可写</li>
<li><strong>通道支持异步读写，是双向的</strong></li>
<li>数据从通道读取到缓冲区，在缓冲区将数据写入到通道</li>
</ul>
</li>
<li>缓冲区：NIO的所有数据都是通过缓冲区处理的，缓冲区实质上是一个可读写的内存块</li>
<li>非阻塞 IO：意味着在数据未准备好时，操作不会阻塞当前线程，而是立即返回</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/java-io-nio-x.png" alt="img" style="zoom:50%;" />

<h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><ul>
<li>AIO（Asynchronous I&#x2F;O），在Java中也被称为Java New I&#x2F;O (<strong>NIO.2</strong>)，是随着JDK 7引入的，它是<strong>真正意义上的异步非阻塞I&#x2F;O</strong>。在AIO模型中，一旦发起了一个异步的读写操作，应用程序就可以继续执行其他任务，<strong>无需进行任何轮询操作去检查I&#x2F;O操作的状态</strong>。当I&#x2F;O操作完成时，会通过之前注册的<strong>回调函数</strong>直接通知应用程序【<strong>事件驱动</strong>】，这种方式更加高效且编程模型更为简洁</li>
<li>异步I&#x2F;O是通过<strong>事件或回调机制</strong>实现的</li>
</ul>
<h3 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h3><ul>
<li><p>IO多路复用就是一个线程同时管理多个IO连接</p>
</li>
<li><p>它允许一个单一的线程（或者有限数量的线程）监控大量的文件描述符（例如，网络套接字），并能有效确定哪些描述符已经准备好进行读取、写入或其他I&#x2F;O操作，而无需为每个连接单独分配一个线程</p>
</li>
</ul>
<h3 id="常见的I-O多路复用技术"><a href="#常见的I-O多路复用技术" class="headerlink" title="常见的I&#x2F;O多路复用技术"></a>常见的I&#x2F;O多路复用技术</h3><ul>
<li><strong>select</strong>：是最原始的多路复用函数，它限制了最大监视的文件描述符数量，并且每次调用都需要重新传入所有描述符集合，效率较低。</li>
<li><strong>poll</strong>：是对select的一个改进，使用链表结构存储文件描述符，解决了select的最大文件描述符数量限制问题，但依然存在轮询所有描述符的效率问题。</li>
<li><strong>epoll</strong>（Linux特有）：提供了更高效的<strong>事件通知机制</strong>，<strong>仅关注发生变化的文件描述符</strong>，避免了无谓的遍历操作。epoll分为水平触发（LT）和边缘触发（ET）两种模式</li>
<li><strong>kqueue</strong>（BSD系统和macOS）：类似于epoll，提供了事件通知机制，支持注册和接收多种类型的事件。</li>
<li><strong>IOCP</strong>（Windows）：输入输出完成端口（Input&#x2F;Output Completion Port），是<strong>Windows平台上用于实现高并发I&#x2F;O操作的机制</strong></li>
</ul>
<h3 id="I-O多路复用工作原理"><a href="#I-O多路复用工作原理" class="headerlink" title="I&#x2F;O多路复用工作原理"></a>I&#x2F;O多路复用工作原理</h3><ol>
<li><p><strong>注册</strong>：应用程序首先将它感兴趣的<strong>文件描述符</strong>（如套接字）和关注的<strong>事件</strong>（读、写、异常）注册到I&#x2F;O多路复用器（如<code>select</code>、<code>poll</code>、<code>epoll</code>）。这意味着程序告诉内核它关心哪些描述符上的哪些类型的操作</p>
</li>
<li><p><strong>内核监控</strong>：操作系统内核接管这些文件描述符，并开始监控它们的状态。内核实际上是通过<strong>硬件中断</strong>来感知这些变化的。操作系统内核与硬件紧密协作，硬件（如网卡）在接收到数据包或准备好发送数据时，会向CPU发送一个中断信号。CPU响应中断后，会执行中断处理程序，这个程序会检查是什么类型的中断并采取相应的行动。对于网络I&#x2F;O而言，中断处理程序会通知内核有新的数据到来或者发送缓冲区已腾出空间。<strong>流程为：硬件状态变化——&gt;给 CPU 发中断信号——&gt;CPU 响应中断——&gt;执行中断处理程序——&gt;通知内核状态变化</strong></p>
</li>
<li><p><strong>事件检测</strong>：</p>
<ul>
<li>对于<code>select</code>和<code>poll</code>，内核会遍历所有注册的描述符来检查状态。这种方法效率较低，特别是在描述符数量很多时</li>
<li><code>select</code>和<code>poll</code>之所以需要遍历所有注册的描述符，是因为它们没有在内核中为每个描述符维护一个持续更新的就绪状态，而是依赖于每次调用时的主动检查</li>
<li><code>epoll</code>采用了不同的策略。在Linux中，epoll使用了两个主要的数据结构：一个红黑树用于存储<strong>已注册的文件描述符</strong>，另一个链表或哈希表用于记录<strong>就绪的文件描述符</strong>。当有事件发生时（如数据到达或缓冲区有空间，内核会监控到状态变化），<strong>内核直接更新就绪列表</strong>。通过就绪列表，内核可以一次性收集一段时间窗口内的所有就绪事件，然后一次性通知应用程序，这样可以减少上下文切换的次数</li>
<li><strong>总结：</strong><code>select</code>和<code>poll</code>在每次调用时都需要主动检查描述符状态，而<code>epoll</code>则是在事件发生时由内核被动地更新就绪列表，调用<code>epoll_wait</code>时直接获取结果，从而提升了性能</li>
</ul>
</li>
<li><p><strong>通知应用</strong>：当有描述符上的事件发生（例如，数据可读或可写），I&#x2F;O多路复用器会通过之前调用的<code>select</code>、<code>poll</code>或<code>epoll_wait</code>等函数返回，告知应用程序哪些描述符已就绪。应用程序可以根据这些信息决定下一步的操作，比如读取数据或发送数据</p>
</li>
<li><p><strong>处理事件</strong>：应用程序收到事件通知后，可以直接<strong>对相应的文件描述符进行操作</strong>，而不必再次检查其状态，因为内核已经确保了这些描述符是可操作的</p>
</li>
</ol>
<p>通过这种方式，I&#x2F;O多路复用器能够高效地通知应用程序哪些连接上有事件发生，从而使得单个线程能够管理大量的并发连接，提高了系统的并发处理能力</p>
<h4 id="为什么更新就绪列表而不是直接通知应用程序"><a href="#为什么更新就绪列表而不是直接通知应用程序" class="headerlink" title="为什么更新就绪列表而不是直接通知应用程序?"></a>为什么更新就绪列表而不是直接通知应用程序?</h4><ol>
<li><strong>批量处理</strong>：如果每当一个事件发生就立即通知应用程序，那么在高并发场景下可能会导致频繁的上下文切换，反而降低效率。通过维护就绪列表，内核可以<strong>一次性收集一段时间窗口内的所有就绪事件</strong>，然后<strong>一次性通知应用程序</strong>，这样可以减少上下文切换的次数。</li>
<li><strong>统一接口</strong>：I&#x2F;O多路复用的API（如<code>epoll_wait</code>）提供了一个统一的接口给应用程序查询就绪的文件描述符，应用程序只需要调用一次就可以得知所有感兴趣的事件，而不需要为每个事件分别处理，这样简化了编程模型</li>
<li><strong>效率与控制</strong>：直接更新就绪列表可以让内核决定何时是通知应用程序的最佳时机，这可以基于各种优化策略，比如<strong>合并事件通知</strong>、避<strong>免惊群效应</strong>等。此外，内核还可以根据就绪事件的数量和类型，决定是否唤醒等待的进程，以及如何高效地调度这些进程</li>
</ol>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>零拷贝（Zero-Copy）是一种计算机程序设计领域的优化技术，旨在减少数据在操作系统内核空间和用户空间之间，以及内核内部的复制次数，从而提高数据传输速度和降低CPU使用率。这一技术特别<strong>适用于大量数据的网络传输或磁盘I&#x2F;O操作</strong>。</p>
<h4 id="mmap【内存映射】-write"><a href="#mmap【内存映射】-write" class="headerlink" title="mmap【内存映射】 + write"></a>mmap【内存映射】 + write</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/java-io-copy-4.png" alt="img" style="zoom:50%;" />

<ol>
<li><p>应用进程调用了 mmap() 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</p>
</li>
<li><p>应用进程再调用 write()，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</p>
</li>
<li><p>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的</p>
</li>
</ol>
<h4 id="Sendfile系统调用"><a href="#Sendfile系统调用" class="headerlink" title="Sendfile系统调用"></a>Sendfile系统调用</h4><ul>
<li><p>在 Linux 内核版本 2.1 中，提供了系统调用函数 sendfile()</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/java-io-copy-5.png" alt="img" style="zoom:50%;" />
</li>
<li><p>从 Linux 内核 2.4 版本开始起，对于网卡支持 SG-DMA 的情况：<strong>全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/java-io-copy-6-20240621115637716.png" alt="img" style="zoom:50%;" />

<ol>
<li><p>通过 DMA 将磁盘上的数据拷贝到内核缓冲区</p>
</li>
<li><p>网卡的 SG-DMA 控制器将内核缓存中的数据拷贝到网卡的缓冲区</p>
</li>
</ol>
</li>
</ul>
<h2 id="JVM和调优"><a href="#JVM和调优" class="headerlink" title="JVM和调优"></a>JVM和调优</h2><h3 id="类加载生命周期"><a href="#类加载生命周期" class="headerlink" title="类加载生命周期"></a>类加载生命周期</h3><p>Java 类加载器（Class Loader）负责将类的字节码文件从不同的位置加载到 JVM 中，并对类进行链接和初始化，以便它们能够在 Java 应用程序中使用。类加载的生命周期通常包含以下<strong>五个阶段</strong>：</p>
<h4 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h4><ul>
<li>查找并加载类的二进制数据（class文件），存储在方法区（Java 8 及以前版本）或元数据区（Java 9 及以后版本）</li>
</ul>
<h4 id="验证（Verification）"><a href="#验证（Verification）" class="headerlink" title="验证（Verification）"></a>验证（Verification）</h4><ul>
<li><p>确保被<strong>加载的类的正确性</strong></p>
</li>
<li><p>JVM 会对类的字节码进行验证，确保其符合 Java 语言规范，不会危害 JVM 的安全。验证过程包括文件格式验证、元数据验证、字节码验证和符号引用验证</p>
</li>
</ul>
<h4 id="准备（Preparation）"><a href="#准备（Preparation）" class="headerlink" title="准备（Preparation）"></a>准备（Preparation）</h4><p>为类的静态变量分配内存，初始化默认值</p>
<h4 id="解析（Resolution）"><a href="#解析（Resolution）" class="headerlink" title="解析（Resolution）"></a>解析（Resolution）</h4><ul>
<li>把类中的<strong>符号引用</strong>转换为<strong>直接引用</strong></li>
<li>符号引用是在编译期间生成的，直接引用则是运行期间可以定位到类、字段、方法等的直接地址或者句柄</li>
</ul>
<h4 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h4><p>为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化</p>
<p><strong>使用： 类访问方法区内的数据结构的接口， 对象是Heap区的数据</strong></p>
<p><strong>卸载： 结束生命周期</strong></p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><blockquote>
<p>Java虚拟机有三个内置的类加载器</p>
</blockquote>
<ul>
<li><strong>Bootstrap ClassLoader</strong>（启动类加载器）：负责加载核心库 lib，如<code>rt.jar</code>等，这个加载器是用C++编写的，没有父加载器</li>
<li><strong>Extension ClassLoader</strong>（扩展类加载器）：负责加载扩展库（<code>$JAVA_HOME/jre/lib/ext</code>）下的jar包或类库，它的父加载器是Bootstrap ClassLoader</li>
<li><strong>Application ClassLoader</strong>（应用程序类加载器）：负责加载用户类路径（ClassPath）上的指定类库，是我们平时开发中默认使用的类加载器，其父加载器是Extension ClassLoader</li>
<li>支持自定义类加载器，<code>extends ClassLoader</code></li>
</ul>
<h3 id="类加载器的缓存机制"><a href="#类加载器的缓存机制" class="headerlink" title="类加载器的缓存机制"></a>类加载器的缓存机制</h3><p>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类</p>
<ol>
<li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li>
<li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li>
<li>如果BootStrapClassLoader加载失败(例如在$JAVA_HOME&#x2F;jre&#x2F;lib里未查找到该class)，会使用ExtClassLoader来尝试加载；</li>
<li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li>
</ol>
<h3 id="Class-forName-和ClassLoader-loadClass-区别"><a href="#Class-forName-和ClassLoader-loadClass-区别" class="headerlink" title="Class.forName()和ClassLoader.loadClass()区别?"></a>Class.forName()和ClassLoader.loadClass()区别?</h3><ul>
<li><code>Class.forName()</code>: 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li><code>ClassLoader.loadClass()</code>: 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象</li>
</ul>
<h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><ol>
<li><p><strong>程序计数器（Program Counter Register）</strong></p>
<p>每个线程都有一个程序计数器，用于存储当前线程所执行的字节码行号或 native 方法的地址。线程私有。</p>
</li>
<li><p><strong>虚拟机栈（Java Virtual Machine Stack）</strong></p>
<ul>
<li><p>每个线程在创建时都会分配一个虚拟机栈，它是线程私有的</p>
</li>
<li><p>当线程执行一个方法时，JVM 会为该方法创建一个栈帧，并将其压入当前线程的虚拟机栈顶</p>
</li>
<li><p>栈帧中存储了方法执行所需的局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息</p>
<ul>
<li><strong>局部变量表</strong>：用于存放方法参数和方法内部定义的局部变量。</li>
<li><strong>操作数栈</strong>：用于存储计算过程中的中间结果，操作数栈的每一个元素可以是任意Java数据类型。</li>
<li><strong>动态链接</strong>：每个栈帧都包含一个执行运行时常量池中该方法所属类的引用，用于支持方法调用过程中的动态连接。</li>
<li><strong>方法返回地址</strong>：当方法执行完毕后，需要通过返回地址来确定下一步程序应该继续执行的位置。</li>
</ul>
</li>
<li><p>Java方法就是在虚拟机栈的栈帧（Stack Frame）中执行的，执行过程中调用其它方法，还会创建新的栈帧入栈，以此类推，当前栈帧执行完毕，就会出栈。</p>
</li>
</ul>
</li>
<li><p><strong>本地方法栈（Native Method Stack）</strong></p>
<ul>
<li><code>native method</code>（本地方法）是指用非Java语言（如C、C++或其他底层语言）编写的方法</li>
<li>每个线程有自己的本地方法栈，是线程私有的</li>
<li>当一个native方法被调用时，也会有相应的栈帧（尽管其结构可能与Java方法的栈帧有所不同，因为它们遵循的是native代码的调用约定），用于维护方法调用的状态，包括局部变量、方法参数以及返回地址等。一旦native方法执行完毕，其栈帧同样会被弹出，以恢复调用前的栈状态</li>
</ul>
</li>
<li><p><strong>堆（Heap）</strong></p>
<p>JVM中最大的一块内存区域，用来存储几乎所有的对象实例和数组。堆是线程共享的</p>
</li>
<li><p><strong>方法区（Method Area）&#x2F; 元空间（Metaspace）</strong></p>
<ul>
<li>用于存储类的元数据、常量、静态变量等。是线程共享。</li>
<li>JDK1.8开始方法区（HotSpot的永久代）被彻底删除了，取而代之的是元空间，元空间直接使用的是本地内存，不再使用堆内存</li>
</ul>
</li>
</ol>
<h3 id="JVM堆内存细分"><a href="#JVM堆内存细分" class="headerlink" title="JVM堆内存细分"></a>JVM堆内存细分</h3><p>在Java 8及之后的版本中，堆内存主要分为两大部分：</p>
<ol>
<li><p><strong>新生代（Young Generation）</strong>: 包括 Eden 空间、两个 Survivor 空间（通常称为 S0 和 S1）。</p>
<ul>
<li><strong>Eden Space</strong>: 新创建的对象首先分配在这里。当Eden区空间不足时，会触发一次Minor GC（也称为YGC）</li>
<li><strong>Survivor Spaces</strong>: 包含两个相同大小的区域，通常称为S0和S1。在每次 Minor GC 后，Eden区存活的对象以及从上次GC的Survivor区（假设为S0）存活下来的对象会被复制到另一个Survivor区（S1）。这个过程用来筛选出频繁被使用的对象，最终晋升到老年代<ul>
<li>一个Survivor区是空的（作为目标to-space），另一个（from-space）包含活的对象。</li>
<li>这个过程重复进行，通常一个对象需要经历几次YGC并在Survivor区之间移动（默认15次回收标记），才会被移到老年代</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>老年代（Old Generation &#x2F; Tenured Generation）</strong></p>
<ul>
<li><p>用于存储经过多次 YGC 后仍然存活的对象</p>
</li>
<li><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象），避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝</p>
</li>
<li><p>老年代的空间一般比新生代大，GC频率相对较低，但是每次GC的时间更长，因为需要进行更复杂的标记-清除或标记-压缩算法</p>
</li>
<li><p>老年代垃圾收集称为 主GC（Major GC）</p>
</li>
</ul>
</li>
</ol>
<p>在 Java8 之前，永久代存在于方法区中。Java8 之后，取消了永久代，方法区也由元空间替代。元空间使用的本地内存，不再使用堆内存。</p>
<h3 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h3><h4 id="判断一个对象是否可回收（存活）？"><a href="#判断一个对象是否可回收（存活）？" class="headerlink" title="判断一个对象是否可回收（存活）？"></a>判断一个对象是否可回收（存活）？</h4><h5 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h5><ul>
<li>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</li>
<li>两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</li>
<li>正因为循环引用的存在，因此 <strong>Java 虚拟机不使用引用计数算法</strong>。</li>
</ul>
<h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><ul>
<li><p>通过 GC Roots 作为起始点进行搜索，<strong>能够到达的对象都是存活</strong>的，不可达的对象可被回收</p>
</li>
<li><p>Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容:</p>
<ul>
<li><p>虚拟机栈中引用的对象</p>
</li>
<li><p>本地方法栈中引用的对象</p>
</li>
<li><p>方法区中类静态变量引用的对象</p>
</li>
<li><p>方法区中的常量引用的对象</p>
</li>
</ul>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/0635cbe8.png" alt="image" style="zoom:50%;" />

<h4 id="对象有哪些引用类型？强软弱虚引用"><a href="#对象有哪些引用类型？强软弱虚引用" class="headerlink" title="对象有哪些引用类型？强软弱虚引用"></a>对象有哪些引用类型？强软弱虚引用</h4><p>Java 具有四种强度不同的引用类型</p>
<h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>被强引用关联的对象不会被回收。</p>
<p>使用 new 一个新对象的方式来创建强引用。</p>
<h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>被软引用关联的对象只有在内存不够的情况下才会被回收（内存不足才回收）</p>
<p>使用 SoftReference 类来创建软引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>被弱引用关联的对象一定会被回收（下次 GC 回收）</p>
<p>使用 WeakReference 类来实现弱引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><ul>
<li><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象</p>
</li>
<li><p>为一个对象设置虚引用关联的唯一目的就是<strong>能在这个对象被回收时收到一个系统通知</strong></p>
</li>
<li><p>使用 PhantomReference 来实现虚引用</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// The object we want to track</span></span><br><span class="line">        ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;(); <span class="comment">// Queue to collect reference objects</span></span><br><span class="line">        PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, queue); <span class="comment">// Create a phantom reference</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// At this point, if `obj` becomes phantom reachable (no strong/soft/weak references left),</span></span><br><span class="line">        <span class="comment">// it becomes eligible for finalization and eventually collection.</span></span><br><span class="line">        </span><br><span class="line">        obj = <span class="literal">null</span>; <span class="comment">// Remove the strong reference</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Simulate GC to trigger finalization and queue insertion (normally done by JVM)</span></span><br><span class="line">        System.gc();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Normally, you would check the queue in another thread continuously</span></span><br><span class="line">        <span class="comment">// to handle cleanup when the reference is enqueued.</span></span><br><span class="line">        <span class="comment">// For demonstration, we just check once here.</span></span><br><span class="line">        <span class="keyword">if</span> (queue.poll() != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Object has been finalized and phantom reference enqueued.&quot;</span>);</span><br><span class="line">            <span class="comment">// Here, you would perform cleanup actions related to the object.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="垃圾回收算法？"><a href="#垃圾回收算法？" class="headerlink" title="垃圾回收算法？"></a>垃圾回收算法？</h4><h5 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记 - 清除"></a>标记 - 清除</h5><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpg" alt="image" style="zoom:50%;" />

<p><strong>标记存活对象</strong>，然后将未被标记的对象清理掉</p>
<p>缺点：</p>
<ul>
<li>标记和清除过程效率都不高</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存</li>
</ul>
<h5 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记 - 整理"></a>标记 - 整理</h5><p>让<strong>存活的对象</strong>移向一端，将端边界以外的内存清理掉</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/902b83ab-8054-4bd2-898f-9a4a0fe52830.jpg" alt="image" style="zoom:50%;" />

<h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><ul>
<li><p>将内存划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
</li>
<li><p>缺点：只使用了内存的一半</p>
</li>
<li><p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p>
<p><strong>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1</strong>，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象</p>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/e6b733ad-606d-4028-b3e8-83c3a73a3797.jpg" alt="image" style="zoom:50%;" />

<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>是一种垃圾回收策略</p>
<h5 id="新生代-复制算法"><a href="#新生代-复制算法" class="headerlink" title="新生代-复制算法"></a>新生代-复制算法</h5><p>每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量 存活对象的复制成本就可以完成收集</p>
<h5 id="老年代-标记整理算法"><a href="#老年代-标记整理算法" class="headerlink" title="老年代-标记整理算法"></a>老年代-标记整理算法</h5><p>对象存活率高、没有额外空间对它进行分配, 就必须采用“标记—清理”或“标 记—整理”算法来进行回收</p>
<h4 id="分区收集算法"><a href="#分区收集算法" class="headerlink" title="分区收集算法"></a>分区收集算法</h4><ul>
<li><p>是一种垃圾回收策略，将整个堆空间划分为连续的小区间, 每个小区间独立使用, 独立回收</p>
</li>
<li><p>垃圾回收器可以灵活选择回收哪些分区，而不是每次都回收整个堆。可以显著降低垃圾回收引起的程序暂停时间</p>
</li>
</ul>
<ol>
<li><strong>G1</strong>： 一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能地满足垃圾收集暂停时间的要求。</li>
<li><strong>ZGC</strong>： JDK11 中推出的一款低延迟垃圾回收器，适用于大内存低延迟服务的内存管理和回收，SPECjbb 2015 基准测试，在 128G 的大堆下，最大停顿时间才 1.68 ms，停顿时间远胜于 G1 和 CMS。</li>
</ol>
<h4 id="什么是Minor-GC、Major-GC、Full-GC"><a href="#什么是Minor-GC、Major-GC、Full-GC" class="headerlink" title="什么是Minor GC、Major GC、Full GC?"></a>什么是Minor GC、Major GC、Full GC?</h4><p>在Java的垃圾回收机制中，根据回收对象所在的内存区域不同，垃圾回收操作主要分为三大类：Minor GC、Major GC（也常被称为Old GC）和Full GC。</p>
<p><strong>Minor GC</strong>: Minor GC主要针对的是Java堆内存中的新生代（Young Generation）。新生代通常被细分为三个子区：Eden区、两个Survivor区（From和To）。大部分新创建的对象首先分配在Eden区。当Eden区满时，会触发一次Minor GC，将Eden区以及Survivor区中仍然存活的对象复制到另一个Survivor区中，同时清理掉未被引用的对象。这个过程相对快速，因为新生代中的对象大多寿命较短，很多对象在第一次或第二次GC后就会被回收。</p>
<p><strong>Major GC（或Old GC）</strong>: Major GC主要针对的是老年代（Old Generation）的垃圾回收。当老年代空间不足或者某些特定条件满足时（比如晋升到老年代的对象过多），会触发Major GC。Major GC通常比Minor GC慢，因为它涉及到的对象更多，且可能需要进行更复杂的标记-压缩或标记-清除算法。虽然Major GC主要关注老年代，但它也可能影响到整个堆，特别是如果老年代的回收导致年轻代对象晋升无处安放时。</p>
<p><strong>Full GC</strong>: 对整个Java堆内存（包括新生代和老年代），方法区进行全面的垃圾回收。也是最消耗资源的一种GC类型，因为它需要停止所有应用线程（Stop-The-World），因此会导致较长的应用暂停时间。</p>
<p>为了保持应用的响应性和整体性能，通常需要尽量减少Major GC和Full GC的发生频率，通过合理的堆内存分配、选择合适的垃圾收集器以及调优GC参数等方式来优化</p>
<h4 id="Full-GC通常在以下情况下发生"><a href="#Full-GC通常在以下情况下发生" class="headerlink" title="Full GC通常在以下情况下发生"></a>Full GC通常在以下情况下发生</h4><ul>
<li><p>调用 <code>System.gc()</code> 或 <code>Runtime.getRuntime().gc()</code>，只是建议 JVM 进行Full GC，JVM 可能会忽略或者执行部分 GC，一般不会执行 Full GC</p>
</li>
<li><p>老年代空间不足</p>
<ul>
<li><p>大对象直接进入老年代、长期存活的对象进入老年代等。</p>
</li>
<li><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间</p>
</li>
</ul>
</li>
<li><p><strong>元空间内存不足不会触发Full GC</strong>，会直接抛出<code>OutOfMemoryError: Metaspace</code></p>
</li>
<li><p>在某些GC算法中，如G1进行并发周期失败时，也可能触发Full GC作为最后的回收手段</p>
</li>
<li><p><strong>其他极端情况</strong>：比如某些严重的数据结构损坏，或者其他内部错误也可能导致JVM执行Full GC</p>
</li>
</ul>
<h4 id="Java8-元空间区的数据是否会进行垃圾回收？"><a href="#Java8-元空间区的数据是否会进行垃圾回收？" class="headerlink" title="Java8+ 元空间区的数据是否会进行垃圾回收？"></a>Java8+ 元空间区的数据是否会进行垃圾回收？</h4><p>会。</p>
<ul>
<li><p>在Java 8中，方法区被元空间取代，元空间使用的是本地内存（Native Memory），而不是虚拟机堆内存</p>
</li>
<li><p>元空间中的垃圾回收主要针对那些不再需要的<strong>类加载器</strong>和<strong>它们加载的类</strong></p>
</li>
</ul>
<h4 id="Java8-元空间触发GC条件？"><a href="#Java8-元空间触发GC条件？" class="headerlink" title="Java8+元空间触发GC条件？"></a>Java8+元空间触发GC条件？</h4><ul>
<li><strong>类加载器不可达</strong>：当一个类加载器实例不再可达，即没有任何引用指向它时，该类加载器以及它所加载的所有类都成为垃圾收集的候选对象。这意味着相关的类和类加载器可以被回收</li>
<li><strong>元空间内存不足</strong>：如果元空间的增长超出了配置的最大限制（通过<code>-XX:MaxMetaspaceSize</code>设置），那么JVM会尝试启动垃圾回收来回收无用的类和类加载器，以释放空间。如果回收后仍然无法满足新的内存分配需求，可能会抛出<code>OutOfMemoryError: Metaspace</code>错误</li>
</ul>
<h4 id="Hotspot中有哪些垃圾回收器？"><a href="#Hotspot中有哪些垃圾回收器？" class="headerlink" title="Hotspot中有哪些垃圾回收器？"></a>Hotspot中有哪些垃圾回收器？</h4><ul>
<li><p>单线程与多线程: 单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程</p>
</li>
<li><p>串行：垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序</p>
</li>
<li><p>并形：垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</p>
</li>
</ul>
<h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><ul>
<li><p>单线程、串行收集器</p>
</li>
<li><p>对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率</p>
</li>
<li><p>Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p>
</li>
</ul>
<h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><ul>
<li><p>Serial 收集器的多线程版本</p>
</li>
<li><p>Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作</p>
</li>
<li><p>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数</p>
</li>
</ul>
<h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><ul>
<li>与 ParNew 一样是多线程收集器</li>
<li><strong>吞吐量优先 收集器</strong>，高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务</li>
</ul>
<h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途:</p>
<ul>
<li>在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h5><ul>
<li><p>Parallel Scavenge 收集器的老年代版本</p>
</li>
<li><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器</p>
</li>
</ul>
<h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>CMS（Concurrent Mark Sweep，并发标记清除）垃圾收集器是Java虚拟机中一种<strong>以获取最短回收停顿时间为目标</strong>的垃圾收集器，适用于对响应时间有严格要求的服务，如大型互联网应用。CMS收集器主要关注如何<strong>缩短用户线程的停顿时间</strong>，通过与用户线程同时运行的方式来减少垃圾收集对应用的影响。</p>
<p>以下是CMS垃圾收集器的主要工作流程：</p>
<ol>
<li><strong>初始标记（Initial Mark）</strong>：用于标记从GC Roots直接可达的对象。这个过程很快，因为只扫描根对象。</li>
<li><strong>并发标记（Concurrent Mark）</strong>：在这个阶段，垃圾收集器与用户线程并发执行。收集器会遍历整个堆，标记所有可到达的对象。这个阶段耗时较长，但因为与用户线程并发执行，所以不会导致应用停顿。</li>
<li><strong>预清理（Precleaning，可选步骤）</strong>：在并发标记完成后，如果发现堆内存使用率较高，可能会执行预清理步骤，以确保有足够的空间容纳接下来的重新标记阶段中可能移动的对象。这一步也是短暂的Stop-The-World操作。</li>
<li><strong>重新标记（Remark）</strong>：这是另一个Stop-The-World事件，用于修正并发标记期间因用户程序继续运行而变动的对象关系。相较于初始标记，这一步耗时更长，但通常仍比老一代的完全垃圾收集要快。</li>
<li><strong>并发清除（Concurrent Sweep）</strong>：此阶段清除已被标记为垃圾的对象，同时用户线程继续运行。这也是一个并发操作，旨在减少应用的暂停时间。</li>
</ol>
<p>CMS收集器的优缺点：</p>
<ul>
<li><strong>优点</strong>：<ul>
<li>减少了应用的停顿时间，提供了较好的用户体验。</li>
<li>在大多数情况下，能与应用程序线程并发执行，提高了系统的吞吐量。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>CPU资源消耗较大，因为并发阶段需要与用户线程争抢CPU资源。</li>
<li>可能会出现内存碎片问题，因为清除过程并不做压缩，长期运行可能导致大对象无法分配空间。</li>
<li>在极端情况下，CMS收集器可能会出现“Concurrent Mode Failure”，这时会退化到使用串行收集器进行一次完整的垃圾收集。</li>
</ul>
</li>
</ul>
<p>自Java 9起，G1（Garbage First）垃圾收集器被推荐作为CMS的替代品，因为G1在很多方面进行了改进，特别是在内存碎片处理和可预测的停顿时间控制上。到了Java 14，CMS垃圾收集器已经被废弃，并在Java 17中完全移除。因此，对于新项目或者升级旧项目时，建议使用G1或ZGC、Shenandoah等更现代的垃圾收集器。</p>
<h5 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h5><p>G1（Garbage First）垃圾收集器是Java平台中的一种先进的垃圾收集器，它从Java 7 Update 4开始可用，并逐渐成为默认的垃圾收集器（Java 9开始推荐，Java 14中CMS被废弃后更为重要）。G1的设计目标是在大内存的多处理器机器上实现<strong>高吞吐量</strong>的同时，还能满足<strong>低延迟</strong>的需求，特别是对垃圾收集暂停时间的可预测性和控制。</p>
<p>G1的主要特点和工作原理包括：</p>
<ol>
<li><strong>分区的堆内存</strong>：G1将堆内存划分为多个大小相等的区域（Region），每个区域可以是Eden、Survivor、老年代或Humongous（巨型）区域之一。这种划分方式允许G1更灵活地管理内存，独立地对各个区域进行垃圾回收。</li>
<li><strong>并行与并发</strong>：G1同样采用并行和并发的方式进行垃圾回收，以减少应用的停顿时间。它在年轻代和老年代的垃圾收集过程中都能实现并行处理。</li>
<li><strong>基于优先级的回收</strong>：G1收集器会优先回收垃圾最多的区域，这也就是其名字“Garbage First”的由来。这种策略能够更有效地利用有限的收集时间回收尽可能多的垃圾。</li>
<li><strong>可预测的停顿时间</strong>：G1提供了暂停预测模型，允许用户设置期望的最大垃圾收集停顿时间目标（-XX:MaxGCPauseMillis）。G1会尽力调整其回收策略，以满足这个目标。</li>
<li><strong>混合收集周期</strong>：G1的垃圾收集过程通常包含年轻代和部分老年代的混合收集。这意味着每次垃圾收集不仅清理年轻代，还会根据需要回收一部分老年代的区域，从而逐步减少老年代的内存占用，避免了传统分代收集器中的全堆收集。</li>
<li><strong>内存压缩</strong>：与CMS不同，G1在垃圾回收过程中能够进行一定程度的内存整理，减少了内存碎片问题。</li>
<li><strong>自动内存管理</strong>：G1具备自适应性，能够自动调整堆的大小、年轻代和老年代的比例等，减少了手动调优的复杂度。</li>
</ol>
<p>尽管G1具有许多优点，但它也有自己的适用场景和限制，比如在极小或极大的堆上可能不是最优选择，且相比其他收集器，它的监控和调优更为复杂。随着Java的发展，ZGC（Zero Garbage Collection）和Shenandoah垃圾收集器也作为低延迟的解决方案被引入，它们在某些场景下可能提供更好的性能表现。</p>
<h5 id="ZGC垃圾收集器"><a href="#ZGC垃圾收集器" class="headerlink" title="ZGC垃圾收集器"></a>ZGC垃圾收集器</h5><p>ZGC（Zero Garbage Collector）是Java中一个先进的<strong>低延迟</strong>垃圾收集器，首次出现在 <code>JDK 11</code>中，并作为实验性功能提供，到了<code>JDK 15</code>之后成为生产就绪状态。ZGC的设计目标是在拥有大量内存的应用程序中实现暂停时间几乎为零的垃圾收集，同时保持高吞吐量。以下是ZGC的一些关键特性和工作原理：</p>
<p>关键特性：</p>
<ol>
<li><strong>低暂停时间</strong>：ZGC旨在实现任意大小堆上的暂停时间不超过10毫秒的目标，即使是在数十到数百GB的堆上。这对于要求极高响应性的应用程序至关重要。</li>
<li><strong>并发标记-复制算法</strong>：ZGC使用一种特殊的并发标记-复制算法，几乎所有的工作都在应用程序线程之外并发完成，这大大减少了垃圾回收导致的暂停时间。</li>
<li><strong>染色指针</strong>：ZGC引入了一种称为“染色指针”的技术，它在指针中编码了额外的信息，如对象是否处于垃圾回收阶段的可达性状态。这一设计使得ZGC无需扫描整个堆来更新指针，减少了停顿时间。</li>
<li><strong>可伸缩性</strong>：ZGC设计为高度并行化，能够有效利用多核处理器，从而在大型系统上提供良好的性能。</li>
<li><strong>无停顿的类卸载</strong>：除了对象分配外，ZGC还能够并发处理类卸载，进一步减少暂停时间。</li>
<li><strong>内存可扩展至数TB</strong>：ZGC支持非常大的堆内存，理论上可以扩展到16EB（虽然实际限制通常由操作系统和硬件决定），适合大数据和内存密集型应用。</li>
</ol>
<p>使用条件与限制：</p>
<ul>
<li><strong>JDK版本</strong>：<strong>ZGC在JDK 15及更高版本中为生产环境准备就绪</strong>，但在早期版本中为实验性功能。</li>
<li><strong>操作系统</strong>：<strong>ZGC目前主要支持Linux和macOS</strong>（Apple Silicon自JDK 17起）。</li>
<li><strong>资源消耗</strong>：虽然ZGC提供了优秀的低延迟特性，但与G1等收集器相比，它可能会消耗更多的内存（因为需要维护读屏障和额外的数据结构），以及在某些情况下可能会有更高的CPU开销。</li>
</ul>
<p>总的来说，ZGC非常适合那些对延迟敏感、需要处理大规模数据集的应用场景。不过，在考虑使用ZGC之前，应该根据具体的应用需求和环境进行评估和测试，以确定它是否是最合适的垃圾收集器选项。</p>
<h3 id="JVM内存相关启动参数"><a href="#JVM内存相关启动参数" class="headerlink" title="JVM内存相关启动参数"></a>JVM内存相关启动参数</h3><h4 id="基本内存配置"><a href="#基本内存配置" class="headerlink" title="基本内存配置"></a>基本内存配置</h4><ol>
<li><strong>-Xms</strong>：设定初始堆大小。控制JVM启动时的内存分配量，单位可以是K、M或G（千字节、兆字节、吉字节）。例如，<code>-Xms256m</code> 设置初始堆大小为256兆字节。</li>
<li><strong>-Xmx</strong>：设定最大堆大小。指定了JVM能够使用的最大内存，超过这个值将会触发OOM（Out Of Memory）错误。单位同样可以是K、M或G。例如，<code>-Xmx1024m</code> 设置最大堆大小为1GB。</li>
</ol>
<h4 id="新生代与老年代配置"><a href="#新生代与老年代配置" class="headerlink" title="新生代与老年代配置"></a>新生代与老年代配置</h4><ol>
<li><strong>-Xmn</strong>：直接设定新生代的大小。如前所述，可以用来精确控制新生代的内存分配，例如，<code>-Xmn512m</code> 设新生代为512兆字节。</li>
<li><strong>-XX:NewRatio</strong>：设置老年代与年轻代的比例。如，<code>-XX:NewRatio=3</code> 表示老年代是新生代的3倍。</li>
<li><strong>-XX:SurvivorRatio</strong>：设置Eden区与Survivor区的比例。默认情况下，一个Survivor区大小是Eden区的1&#x2F;8或1&#x2F;10，通过这个参数可以调整。如，<code>-XX:SurvivorRatio=6</code> 表示一个Survivor区是Eden区的1&#x2F;6大小。</li>
</ol>
<h4 id="其他高级内存配置"><a href="#其他高级内存配置" class="headerlink" title="其他高级内存配置"></a>其他高级内存配置</h4><ol>
<li><strong>-XX:MaxPermSize</strong>（JDK 8之前）：设定永久代（PermGen）的最大大小。在JDK 8之后，永久代被元空间（Metaspace）取代，应使用<code>-XX:MaxMetaspaceSize</code>。</li>
<li><strong>-XX:MetaspaceSize</strong>：设置元空间的初始大小。</li>
<li><strong>-XX:MaxMetaspaceSize</strong>（可选）：限制元空间的最大大小。如果不设置，默认情况下，元空间可以无限增长，仅受系统内存限制。</li>
<li><strong>-XX:InitialHeapSize</strong> 和 <strong>-XX:MaxHeapSize</strong>：这两个参数分别等价于 <code>-Xms</code> 和 <code>-Xmx</code>，提供了一种更长的命名方式。</li>
</ol>
<h4 id="垃圾收集器相关参数"><a href="#垃圾收集器相关参数" class="headerlink" title="垃圾收集器相关参数"></a>垃圾收集器相关参数</h4><ol>
<li><strong>-XX:+UseSerialGC</strong>、**-XX:+UseParallelGC<strong>、</strong>-XX:+UseConcMarkSweepGC<strong>、</strong>-XX:+UseG1GC**：选择不同的垃圾收集器。每种收集器有其独特的内存管理策略和适用场景。</li>
<li><strong>-XX:ParallelGCThreads</strong>：对于并行垃圾收集器（如Parallel GC），设置垃圾回收时使用的线程数。</li>
</ol>
<h4 id="监控与诊断"><a href="#监控与诊断" class="headerlink" title="监控与诊断"></a>监控与诊断</h4><ol>
<li><strong>-XX:+PrintGCDetails</strong>：打印垃圾收集的详细信息到标准输出，有助于分析GC行为。</li>
<li><strong>-XX:+HeapDumpOnOutOfMemoryError</strong>：当发生OOM错误时，自动创建堆转储文件，便于事后分析。</li>
</ol>
<h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><h4 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h4><p>复现问题、查看日志、远程调试、分析异常堆栈、性能监控、内存分析、并发问题检查、版本比对、缩小范围、单元测试、社区和文档</p>
<h4 id="Linux定位问题的工具"><a href="#Linux定位问题的工具" class="headerlink" title="Linux定位问题的工具"></a>Linux定位问题的工具</h4><h5 id="网络、防火墙、磁盘、内存、环境变量、日志"><a href="#网络、防火墙、磁盘、内存、环境变量、日志" class="headerlink" title="网络、防火墙、磁盘、内存、环境变量、日志"></a>网络、防火墙、磁盘、内存、环境变量、日志</h5><ul>
<li>文本操作 <ul>
<li>文本查找 - grep</li>
<li>文本分析 - awk</li>
<li>文本处理 - sed</li>
</ul>
</li>
<li>文件操作 <ul>
<li>文件监听 - tail</li>
<li>文件查找 - find</li>
</ul>
</li>
<li>网络和进程 <ul>
<li>网络接口 - ifconfig</li>
<li>防火墙 - iptables -L</li>
<li>路由表 - route -n</li>
<li>netstat</li>
</ul>
</li>
<li>其它常用 <ul>
<li>进程 ps -ef | grep java</li>
<li>分区大小 df -h</li>
<li>内存 free -m</li>
<li>硬盘大小 fdisk -l |grep Disk</li>
<li>top</li>
<li>环境变量 env</li>
</ul>
</li>
</ul>
<h4 id="JDK自带的工具？"><a href="#JDK自带的工具？" class="headerlink" title="JDK自带的工具？"></a>JDK自带的工具？</h4><h5 id="jps、jstack、jmap、jinfo、jstat"><a href="#jps、jstack、jmap、jinfo、jstat" class="headerlink" title="jps、jstack、jmap、jinfo、jstat"></a>jps、jstack、jmap、jinfo、jstat</h5><ul>
<li><strong>jps</strong> 查看当前java进程的小工具， 可以看做是JavaVirtual Machine Process Status Tool的缩写</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps –l <span class="comment"># 输出进程ID和全路径的应用主类名，示例 16694 com.neo.ActuatorApplication </span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>jstack</strong> <strong>线程堆栈分析</strong>工具，使用该命令可以查看或导出 Java 应用程序中线程堆栈信息。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本</span></span><br><span class="line">jstack 2815</span><br><span class="line">jstack -m 2815 <span class="comment"># java和native c/c++框架的所有栈信息</span></span><br><span class="line">jstack -l 2815 <span class="comment"># 额外的锁信息列表，查看是否死锁</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>jinfo</strong> 查看正在运行的 java 应用程序的扩展参数，包括 <strong>Java 系统属性</strong>和 <strong>JVM参数</strong>；也可以动态的修改正在运行的 JVM 一些参数。当系统崩溃时，jinfo可以从core文件里面知道崩溃的Java应用程序的配置信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo 2815 <span class="comment"># 输出当前 jvm 进程的全部参数和系统属性</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>jmap</strong> 用于<strong>生成堆内存的快照</strong>（heap dump）或<strong>打印Java进程的内存详情</strong>。这个工具对于分析<strong>内存泄漏</strong>、<strong>监控内存使用情况</strong>以及<strong>故障诊断</strong>非常有用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看堆的情况</span></span><br><span class="line">jmap -heap 2815</span><br><span class="line"></span><br><span class="line"><span class="comment"># dump</span></span><br><span class="line">jmap -dump:live,format=b,file=/tmp/heap2.bin 2815</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>jstat</strong> 可以显示包括<strong>类加载</strong>、<strong>内存使用</strong>、<strong>垃圾收集</strong>等多种与 JVM 性能相关的信息。它的工作原理是直接读取 JVM 的内部统计结构，因此可以提供实时的监控数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil 2815 1000 </span><br></pre></td></tr></table></figure>

<h4 id="Java-诊断工具Arthas？"><a href="#Java-诊断工具Arthas？" class="headerlink" title="Java 诊断工具Arthas？"></a>Java 诊断工具Arthas？</h4><p>阿里巴巴开源的 Java 诊断工具，用于在线调试 Java 应用，实时监控与诊断问题，无需重启 JVM，大大提升线上问题排查效率</p>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul>
<li>分析线程、内存：<code>dashboard</code>、<code>thread</code></li>
<li><code>sc</code>、<code>sm</code>查询类或方法加载：某个类或方法是否被加载</li>
<li><code>jad</code> 查看类或方法源码</li>
<li><code>watch</code> 监控方法入参、返回值，执行耗时</li>
<li>方法调用栈分析：<code>stack</code></li>
<li>代码热更新：<code>jad</code>、<code>mc</code>、<code>redefine</code></li>
</ul>
<h5 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h5><ol>
<li><strong>下载</strong>：<code>curl -O https://arthas.aliyun.com/arthas-boot.jar</code></li>
<li><strong>启动</strong>：在目标 Java 应用的服务器上，通过命令行启动 Arthas，通常命令为 <code>java -jar arthas-boot.jar</code></li>
<li><strong>连接</strong>：Arthas 会列出当前系统中所有运行的 Java 进程，你可以选择一个进程连接</li>
<li><strong>使用命令</strong>：连接后，就可以开始使用 Arthas 提供的各种命令进行诊断和分析了</li>
</ol>
<h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><ul>
<li><p><strong>查看 dashboard</strong></p>
<p>实时监控进程、JVM内存、运行环境信息</p>
</li>
</ul>
<ul>
<li><strong>thread - 查看最繁忙的线程，以及是否有阻塞情况发生</strong>?</li>
</ul>
<p>场景：我想看下查看最繁忙的线程，以及是否有阻塞情况发生? 常规查看线程，一般我们可以通过 top 等系统命令进行查看，但是那毕竟要很多个步骤，很麻烦。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread -n 3 <span class="comment"># 查看最繁忙的三个线程栈信息</span></span><br><span class="line">thread  <span class="comment"># 以直观的方式展现所有的线程情况</span></span><br><span class="line">thread -b <span class="comment">#找出当前阻塞其他线程的线程</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>sc、sm - 确认某个类、方法是否已被系统加载</strong>?</li>
</ul>
<p>场景：我新写了一个类或者一个方法，我想知道新写的代码是否被部署了?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 即可以找到需要的类全路径，如果存在的话</span></span><br><span class="line">sc *MyServlet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看这个某个类所有的方法</span></span><br><span class="line">sm pdai.tech.servlet.TestMyServlet *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个方法的信息，如果存在的话</span></span><br><span class="line">sm pdai.tech.servlet.TestMyServlet testMethod  </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>jad - 查看一个class类的源码信息</strong></li>
</ul>
<p>场景：我新修改的内容在方法内部，而上一个步骤只能看到方法，这时候可以反编译看下源码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接反编译出java 源代码，包含一此额外信息的</span></span><br><span class="line">jad pdai.tech.servlet.TestMyServlet</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>watch - 跟踪某个方法的入参、返回值和执行耗时</strong></li>
</ul>
<p>场景：我想看下我新加的方法在线运行的参数和返回值?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># watch [类名] [方法名] [表达式] [-b 访问前执行] [-a 访问后执行] [--skipJDKMethod true|false] [其他选项]</span></span><br><span class="line"><span class="comment"># 同时监控入参，返回值，及异常</span></span><br><span class="line">[arthas@18520]$ watch com.neo.controller.HelloController index</span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class count: 1 , method count: 1) cost <span class="keyword">in</span> 31 ms, listenerId: 5</span><br><span class="line">method=com.neo.controller.HelloController.index location=AtExit</span><br><span class="line">ts=2024-06-22 18:17:12; [cost=0.02602ms] result=@ArrayList[</span><br><span class="line">    @Object[][isEmpty=<span class="literal">true</span>;size=0],</span><br><span class="line">    @HelloController[com.neo.controller.HelloController@3278f73d],</span><br><span class="line">    @String[Hello World],</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>stack - 查看方法调用栈的信息</strong></li>
</ul>
<p>场景：我想看下某个方法的调用栈的信息?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack pdai.tech.servlet.TestMyServlet testMethod</span><br></pre></td></tr></table></figure>

<p>运行此命令之后需要即时触发方法才会有响应的信息打印在控制台上</p>
<ul>
<li><strong>找到最耗时的方法调用</strong>?</li>
</ul>
<p>场景：testMethod这个方法入口响应很慢，如何找到最耗时的子调用?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行的时候每个子调用的运行时长，可以找到最耗时的子调用。</span></span><br><span class="line">stack pdai.tech.servlet.TestMyServlet testMethod</span><br></pre></td></tr></table></figure>

<p>运行此命令之后需要即时触发方法才会有响应的信息打印在控制台上，然后一层一层看子调用。</p>
<ul>
<li><strong>mc、redefine - 临时更改代码运行</strong></li>
</ul>
<p>场景：我找到了问题所在，能否线上直接修改测试，而不需要在本地改了代码后，重新打包部署，然后重启观察效果?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先反编译出class源码</span></span><br><span class="line">jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后使用外部工具编辑内容</span></span><br><span class="line">mc /tmp/UserController.java -d /tmp  <span class="comment"># 再编译成class</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后，重新载入定义的类，就可以实时验证你的猜测了</span></span><br><span class="line">redefine /tmp/com/example/demo/arthas/user/UserController.class</span><br></pre></td></tr></table></figure>

<p>如上，是直接更改线上代码的方式，但是一般好像是编译不成功的。所以，最好是本地ide编译成 class文件后，再上传替换为好！</p>
<p>总之，已经完全不用重启和发布了！这个功能真的很方便，比起重启带来的代价，真的是不可比的。比如，重启时可能导致负载重分配，选主等等问题，就不是你能控制的了。</p>
<ul>
<li><strong>测试某个方法的性能问题</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitor -c 5 demo.MathGame primeFactors</span><br></pre></td></tr></table></figure>

<h4 id="Idea的远程调试-Xdebug"><a href="#Idea的远程调试-Xdebug" class="headerlink" title="Idea的远程调试 -Xdebug"></a>Idea的远程调试 -Xdebug</h4><p>要让远程服务器运行的代码支持远程调试，则启动的时候必须加上特定的 JVM 参数，这些参数是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xdebug -Xrunjdwp:transport=dt_socket,suspend=n,server=y,address=9000</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/UTOOLS1577248189148.gif" alt="UTOOLS1577248189148.gif" style="zoom:50%;" />

<p>IDEA 启动 <code>Remote_debug</code> 后，在代码中设置断点，等待远程访问触发断点即可</p>
<h2 id="Java-新版本"><a href="#Java-新版本" class="headerlink" title="Java 新版本"></a>Java 新版本</h2><h3 id="Java-8-特性"><a href="#Java-8-特性" class="headerlink" title="Java 8 特性"></a>Java 8 特性</h3><h4 id="接口支持-default-实现方法"><a href="#接口支持-default-实现方法" class="headerlink" title="接口支持 default 实现方法"></a>接口支持 default 实现方法</h4><ul>
<li>接口可以有实现方法，只需在前面加个 default 关键字即可</li>
<li>一个接口可以有1 个或多个default 方法</li>
<li>一个类实现了包含有 default 方法的接口，则继承了该方法，也可以重写该方法</li>
<li>一个类实现了多个接口，每个接口有相同的default 方法（不同实现），那么这个类必须重写这个方法，否则编译报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Calling A.foo()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Clazz</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       <span class="type">Clazz</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clazz</span>();</span><br><span class="line">       clazz.foo();<span class="comment">//调用A.foo()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口支持静态方法"><a href="#接口支持静态方法" class="headerlink" title="接口支持静态方法"></a>接口支持静态方法</h4><ul>
<li>允许接口中包含静态方法，支持一个或多个</li>
<li>通过接口直接调用静态方法（静态方法属于接口）</li>
</ul>
<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><ul>
<li>函数式接口中只包含一个抽象方法</li>
<li>函数式接口中可以有 default 实现方法和静态方法</li>
<li>可以使用<code>@FunctionalInterface</code>注解可以标记在接口上，以明确指定这是一个函数式接口，编译时会做检查</li>
<li>可以利用Lambda表达式书写，这是一种更简洁、更功能化的编程方式</li>
</ul>
<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><ul>
<li>Lambda 表达式提升了代码的简洁性、可读性</li>
<li>lambda表达式，基于函数式接口，表达的是<strong>接口函数</strong>，箭头左侧是<strong>函数参数</strong>，箭头右侧是<strong>函数体</strong></li>
<li>函数的参数类型和返回值类型都可以省略，程序会根据接口定义的上下文自动确定数据类型</li>
<li><strong>简化匿名内部类</strong>: 在Java 8之前，为了实现接口或者抽象类的一个方法，通常需要创建一个匿名内部类。Lambda表达式提供了一种更简洁的方式来实现这样的功能，减少了大量的模板代码</li>
</ul>
<h4 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h4><ul>
<li><strong>提升代码自解释性</strong>：明确表达可能存在空值的情况，有助于避免空指针异常（NullPointerException）</li>
<li><code>ifPresent()</code> 如果 optional 对象中的值不为空的话，执行一些操作</li>
<li><code>isPresent()</code> 判断 optional 对象中的值是否存在（非空）</li>
<li><strong>链式调用</strong>：<code>Optional</code>提供了丰富的API，如<code>map()</code>, <code>flatMap()</code>, <code>orElse()</code>, <code>orElseGet()</code>, <code>orElseThrow()</code>等，使得可以很容易地进行一系列操作而无需显式检查中间结果是否为null，这有助于写出更简洁、易读的代码</li>
<li><strong>促进函数式编程</strong>：<code>Optional</code>与Java 8的流(Streams)和Lambda表达式紧密配合，促进了更加函数式风格的编程，使得代码更加声明式，易于理解和维护</li>
</ul>
<h4 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h4><ul>
<li><strong>使用场景</strong>：类型注解可以被应用在类声明、接口声明、方法和构造器的返回类型、方法和构造器的参数类型、泛型类型参数、数组类型、局部变量声明、类型强制转换以及新实例的创建等位置</li>
<li><strong>编译时验证</strong>：类型注解特别适合于<strong>编译时强类型检查</strong>，比如可以通过注解来标记某些类型必须满足特定的约束条件，然后利用注解处理器在编译阶段检查这些约束是否被遵守</li>
<li><strong>不改变语义</strong>：类型注解本身并不改变程序的运行时行为，它们主要提供给编译器和其他工具使用</li>
<li><strong>@Target</strong> 扩展：为了让注解能够应用在类型上下文中，<code>java.lang.annotation.ElementType</code>枚举中添加了新的元素，如<code>TYPE_USE</code>和<code>TYPE_PARAMETER</code>。<code>TYPE_USE</code>表示注解可以应用于任何类型使用的地方，而<code>TYPE_PARAMETER</code>则专用于泛型类型参数声明</li>
<li>示例 <code>@NonNull</code>、<code>@Readonly</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类型注解</span></span><br><span class="line"><span class="comment">// SOURCE-注解只存在于源码中，编译后会被丢弃，不会出现在.class文件中</span></span><br><span class="line"><span class="comment">// CLASS - 注解存在于源码和编译后的.class文件中，但运行时不可访问。</span></span><br><span class="line"><span class="comment">// RUNTIME - 注解存在于源码、编译后的.class文件中，并且在运行时通过反射可以访问到</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> </span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE_USE&#125;)</span> <span class="comment">// 关键在这里，允许应用于类型使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NonNull &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span> String str; <span class="comment">// 变量声明上的类型注解</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exampleMethod</span><span class="params">(<span class="meta">@NonNull</span> String param)</span> &#123; <span class="comment">// 参数类型上的类型注解</span></span><br><span class="line">        List&lt;<span class="meta">@NonNull</span> String&gt; list; <span class="comment">// 泛型类型上的类型注解</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><h3 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h3><p>数据操作基本上就是增、删、改、查、排序</p>
<h4 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 (Array)"></a>数组 (Array)</h4><ul>
<li><strong>数组是一种线性数据结构</strong>，用于存储固定数量的同类型元素。每个元素都有一个索引，从0开始计数。</li>
<li>支持根据<strong>索引下标快速查询数据</strong>，但插入、删除操作较慢（可能需要移动大量元素）。在一个增删比较频繁的数据结构中，数组不会被优先考虑</li>
</ul>
<h4 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表 (Linked List)"></a>链表 (Linked List)</h4><ul>
<li><strong>链表也是一种线性结构</strong>，但与数组不同，它的元素在内存中不是连续存放的。每个元素（节点）包含数据和指向下一个节点的指针。</li>
<li>插入和删除操作快（只需修改指针），但<strong>查询效率不高</strong>（需要遍历链表），<strong>适用于频繁插入&#x2F;删除的场景</strong></li>
<li><strong>单向链表</strong>：例如每个节点中存储下一个节点的引用，而没有上一个节点的引用。查找时只能单向查找</li>
<li><strong>双向链表</strong>：每个节点中既包含下一个节点的引用，也包含上一个节点的引用，在查找时支持双向查找</li>
</ul>
<h4 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 (Stack)"></a>栈 (Stack)</h4><ul>
<li>栈是一种<strong>后进先出</strong>（LIFO, Last In First Out）的数据结构，只允许在一端（栈顶）进行添加和移除操作。</li>
<li>理解要点：常用于函数调用等场景，体现了“先进后出”的逻辑。</li>
</ul>
<h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 (Queue)"></a>队列 (Queue)</h4><ul>
<li>队列遵循<strong>先进先出</strong>（FIFO, First In First Out）原则，一端添加（入队），另一端移除（出队）。</li>
<li>理解要点：广泛应用于需要处理一系列任务的场景，如打印队列、CPU调度等。</li>
</ul>
<h4 id="哈希表-Hash-Table"><a href="#哈希表-Hash-Table" class="headerlink" title="哈希表 (Hash Table)"></a>哈希表 (Hash Table)</h4><ul>
<li>使用<strong>哈希函数</strong>根据键（Key）确定存储位置</li>
<li>存在<strong>哈希冲突</strong>时，需要通过链地址法或开放寻址法解决</li>
<li>是<strong>数组和链表的折中</strong>，同时它的设计依赖散列函数的设计，数组不能无限长、链表也不适合查找，所以也不适合大规模的查找</li>
</ul>
<h4 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树 (Tree)"></a>树 (Tree)</h4><p><strong>树是一种分层数据结构</strong>，由节点组成，每个节点可以有零个或多个子节点</p>
<ul>
<li><p><strong>二叉树</strong></p>
<ul>
<li>介绍<ul>
<li><strong>节点结构</strong>：每个节点包含一个数据元素以及指向左子节点和右子节点的引用（指针或链接）。对于没有子节点的情况，对应的引用可以是空（null）</li>
<li><strong>根节点</strong>：二叉树的顶部节点称为根节点，它没有父节点</li>
<li><strong>叶节点（终端节点）</strong>：没有子节点的节点称为叶节点</li>
<li><strong>边</strong>：连接节点的线称为边。在二叉树中，从一个节点到其子节点的边有明确的方向性，<strong>从父节点指向子节点</strong></li>
</ul>
</li>
<li><strong>二叉搜索树（Binary Search Tree, BST）</strong>：左子树所有节点的值小于父节点，右子树所有节点的值大于父节点。『左小右大』</li>
<li><strong>平衡二叉树</strong>：<strong>每个节点的左右子树高度差不能超过1</strong>，如AVL树和红黑树都是平衡二叉树的实例<ul>
<li>AVL树：<strong>严格平衡二叉搜索树</strong><ul>
<li>适用于插入与删除较少，查找多的情况</li>
<li>AVL树通过每次插入或删除节点后重新计算节点的高度，并检查是否满足平衡条件（任何节点的两个子树的高度差不超过1），如果不满足则<strong>通过旋转操作来恢复平衡</strong></li>
<li><strong>严格平衡</strong>：AVL树要求高度平衡，任何节点的两个子树高度之差最多为1。</li>
<li><strong>旋转操作</strong>：包括单旋转（左旋、右旋）和双旋转（左右旋、右左旋）来恢复平衡。</li>
<li><strong>较高的平衡度</strong>：这使得AVL树的查找效率非常高，最坏情况下的时间复杂度为O(log n)。</li>
</ul>
</li>
<li><strong>红黑树</strong>：非完全平衡二叉树，在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。<strong>适用于搜索，插入，删除操作较多的情况</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>B树</strong></p>
<ul>
<li>自平衡多叉树</li>
<li>包含根节点、内部节点和叶子节点</li>
<li>每个节点都可以包含数据（data）和一个或多个键值（keys），以及指向子节点的指针。这意味着在B树中，数据分散在树的所有节点上</li>
<li>由于数据可能在任何层级的节点中，范围查询可能需要在树的多个层级进行，效率相对较低</li>
<li>每个节点存储数据可能导致节点能存储的键值较少，增加了树的高度，从而可能增加磁盘I&#x2F;O操作次数</li>
<li>适用于读写相对大的数据块的存储系统，例如磁盘。它的应用是<strong>文件系统</strong>及<strong>部分非关系型数据库索引</strong></li>
</ul>
</li>
<li><p><strong>B+树</strong></p>
<ul>
<li>自平衡多叉树</li>
<li>包含根节点、内部节点和叶子节点</li>
<li>只有叶子节点才存储实际的数据（或者指向数据的指针），而内部节点只存储键值作为索引（导航作用），以及指向子节点的指针。这使得B+树的内部节点可以容纳更多的键值，降低了树的高度，提高了磁盘读写的效率</li>
<li>B+ 树是 <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/b-tree/">B 树</a> 的一个升级，它比 B 树更适合实际应用中操作系统的<strong>文件索引</strong>和<strong>数据库索引</strong>。目前现代关系型数据库最广泛的支持索引结构就是 B+ 树</li>
<li>B+ 树是一种<strong>多叉排序树</strong>，即每个节点通常有多个子节点</li>
<li>叶子节点通过指针相连，形成了一个有序链表，便于范围查询</li>
</ul>
</li>
</ul>
<h4 id="图-Graph"><a href="#图-Graph" class="headerlink" title="图 (Graph)"></a>图 (Graph)</h4><ul>
<li>图是由节点（顶点）和边（连接节点的线）组成，用来表示对象之间的关系</li>
<li>理解要点：分为有向图和无向图，常用于网络路由、社交网络分析等问题</li>
</ul>
<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><h4 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h4><p>分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解</p>
<h4 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h4><ul>
<li>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</li>
<li>动态规划算法求解的问题经过分解后得到的子问题往往不是独立的，而是下一个子阶段的求解是建立在上一个子阶段的解的基础上的</li>
</ul>
<h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><p>保证每次操作都是局部最优的，并且最后得到的结果是全局最优的</p>
<h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><p>比如重要的二分法，比如二分查找；二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列</p>
<h4 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h4><p>主要包含BFS，DFS</p>
<h4 id="Backtracking-回溯"><a href="#Backtracking-回溯" class="headerlink" title="Backtracking(回溯)"></a>Backtracking(回溯)</h4><p>属于 DFS, 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 (Bubble Sort)"></a>冒泡排序 (Bubble Sort)</h4><ul>
<li><strong>总结：遍历、相邻比较、交换</strong></li>
<li>简单直观，通过重复遍历要排序的数列，比较相邻元素并在必要时交换它们的位置，直到没有再需要交换的元素为止。</li>
</ul>
<h4 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 (Quick Sort)"></a>快速排序 (Quick Sort)</h4><ul>
<li><strong>总结：选基准元素，一边小，一边大，各边继续排</strong></li>
<li>采用分治法策略，选取一个“基准”元素，通过一趟排序将待排序的记录分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据要小，然后再按此方法对这两部分数据分别进行快速排序。</li>
</ul>
<h4 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序(Insertion Sort)"></a>插入排序(Insertion Sort)</h4><ul>
<li><strong>总结：依次取出未排序元素，插入已排序中合适位置</strong></li>
<li>将数组分为已排序和未排序两部分，依次取出未排序部分的元素，在已排序部分找到合适的位置将其插入，直到全部元素排序完成。</li>
</ul>
<h4 id="选择排序-Selection-sort"><a href="#选择排序-Selection-sort" class="headerlink" title="选择排序(Selection sort)"></a>选择排序(Selection sort)</h4><ul>
<li><p><strong>总结：选择未排序中最小(or最大)元素，放到已排序末尾</strong></p>
</li>
<li><p>它的基本思想是: 首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
</li>
</ul>
<h4 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a>归并排序(Merge Sort)</h4><ul>
<li><strong>总结：拆分，排序，合并</strong></li>
<li>也是分治法，将数组分成两半，分别排序，然后将两个有序数组合并成一个有序数组</li>
</ul>
<h4 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h4><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><h4 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h4><p>也称为<strong>哈希函数</strong>、<strong>散列函数</strong>或消息摘要，是一种<strong>将任意长度的数据映射为固定长度输出的算法</strong>。其主要特点和用途包括：</p>
<ol>
<li><strong>不可逆性</strong>：摘要算法的输出（哈希值或消息摘要）通常是无法从输出反推回原始数据的。这意味着，给定一个哈希值，很难找到或构造出原始输入数据，这为数据的安全存储提供了基础。</li>
<li><strong>确定性</strong>：对于同一输入数据，无论何时何地执行摘要算法，都会得到相同的结果。这保证了哈希值的一致性和可验证性。</li>
<li><strong>敏感性</strong>：即使是原始数据的微小变化，也会导致哈希值产生看似随机且显著不同的变化。这一特性使得摘要算法非常适合用于检测数据完整性。</li>
<li><strong>抗碰撞性</strong>：理想的摘要算法应使找到两个不同输入但有相同输出的情况非常困难（这称为弱碰撞性），并且几乎不可能找到这样的输入对（强碰撞性）。虽然理论上没有绝对安全的哈希函数，但好的摘要算法应该尽可能难以被破解。</li>
</ol>
<p>常见的摘要算法有：</p>
<ul>
<li><strong>MD5</strong>：一种广泛使用的128位哈希函数，虽然曾经很流行，但由于安全性问题现在不推荐用于安全认证。</li>
<li><strong>SHA-1</strong>：比MD5更安全的160位摘要算法，但近年来也被证明存在安全弱点，不建议用于新的安全应用。</li>
<li><strong>SHA-2</strong>（包括SHA-256, SHA-512等）：作为SHA-1的加强版，目前被广泛认为是安全的，用于多种安全协议和标准中。</li>
<li><strong>SHA-3</strong>：最新的安全哈希算法系列，设计用于替代SHA-2，具有更好的安全性和灵活性。</li>
</ul>
<p>摘要算法在密码学、数据校验、数字签名、文件完整性验证、数据库索引等多个领域有着广泛应用。</p>
<h4 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h4><ul>
<li>对称加密使用相同的密钥进行数据的加密和解密。这种类型的加密算法简单高效，适合于大量数据的加密，但密钥的管理和分发是一个挑战，因为所有参与通信的双方都必须安全地知道这个密钥。</li>
<li><strong>加密、解密速度快，适合大量数据的快速传输</strong></li>
</ul>
<p>常见对称加密算法有：</p>
<ul>
<li><strong>AES（Advanced Encryption Standard）</strong>：高级加密标准，是最常用的对称加密算法之一，支持128、192、256位密钥长度，广泛应用于各种安全场景。</li>
<li><strong>DES（Data Encryption Standard）</strong>：数据加密标准，较老的算法，密钥长度为56位，因安全性较低已逐渐被AES取代。</li>
<li><strong>3DES（Triple DES）</strong>：是DES的增强版，通过使用三个不同的密钥对数据进行三次加密，有效密钥长度达到112或168位，提高了安全性。</li>
</ul>
<h4 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h4><ul>
<li>非对称加密算法使用一对密钥：公钥和私钥。<strong>公钥用于加密数据，而私钥用于解密数据</strong>。由于公钥可以公开，而私钥需要保密，这种方式解决了密钥分发的问题，常用于身份验证、数字签名和密钥交换场景。</li>
<li><strong>不适合大数据量的加密解密，速度慢</strong></li>
</ul>
<p>常见非对称加密算法有：</p>
<ul>
<li><strong>RSA</strong>：基于大数因子分解难题的算法，是最著名的非对称加密算法之一，广泛应用于SSL&#x2F;TLS协议、电子邮件加密等。</li>
<li><strong>ECC（Elliptic Curve Cryptography）</strong>：椭圆曲线密码学，相比RSA，ECC能够在更短的密钥长度下提供相同的安全强度，更适合资源受限的环境。</li>
<li><strong>DH（Diffie-Hellman）</strong> 和 <strong>ECDH（Elliptic Curve Diffie-Hellman）</strong>：这两种算法用于安全密钥交换，使得两方可以在不安全的通道上协商出一个共享的密钥。</li>
</ul>
<h4 id="混合加密系统"><a href="#混合加密系统" class="headerlink" title="混合加密系统"></a>混合加密系统</h4><ul>
<li>在实际应用中，通常会结合使用对称加密和非对称加密，形成混合加密系统</li>
<li>例如<strong>HTTPS</strong> ，<strong>利用非对称加密（RSA）来安全地交换对称加密（如AES密钥）的密钥</strong>，然后<strong>使用对称加密算法来加密数据</strong>。这样既利用了非对称加密的安全性，又发挥了对称加密的高效性。</li>
</ul>
<h4 id="国密算法"><a href="#国密算法" class="headerlink" title="国密算法"></a>国密算法</h4><ul>
<li>SM1 <strong>为对称加密</strong>。其加密强度与AES相当。该算法不公开，调用该算法时，需要通过<strong>加密芯片的接口进行调用</strong>。</li>
<li>SM2 <strong>非对称加密</strong>，基于ECC。该算法已公开。由于该算法基于ECC，故其签名速度与秘钥生成速度都快于RSA。ECC 256位（SM2采用的就是ECC 256位的一种）安全强度比RSA 2048位高，但运算速度快于RSA。</li>
<li>SM3 <strong>消息摘要</strong>。可以用MD5作为对比理解。该算法已公开。校验结果为256位。</li>
<li>SM4 无线局域网标准的<strong>分组数据算法</strong>。对称加密，密钥长度和分组长度均为128位。</li>
<li>SM7 是一种分组密码算法，分组长度为128比特，密钥长度为128比特。SM7适用于非接触式IC卡，应用包括身份识别类应用(门禁卡、工作证、参赛证)，票务类应用(大型赛事门票、展会门票)，支付与通卡类应用（积分消费卡、校园一卡通、企业一卡通等）。</li>
<li>SM9 不需要申请数字证书，适用于互联网应用的各种新兴应用的安全保障。如基于云技术的密码服务、电子邮件安全、智能终端保护、物联网安全、云存储安全等等。这些安全应用可采用手机号码或邮件地址作为公钥，实现数据加密、身份认证、通话加密、通道加密等安全应用，并具有使用方便，易于部署的特点，从而开启了普及密码算法的大门。</li>
</ul>
<h3 id="领域算法"><a href="#领域算法" class="headerlink" title="领域算法"></a>领域算法</h3><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><ul>
<li>用于测试一个元素是否在一个集合中。它的主要特点是空间效率高，但是可能会有误报（false positives），即判断一个不在集合中的元素可能被错误地标记为在集合中，但它绝不会错误地判断一个在集合中的元素不在集合中（即不存在false negatives）。</li>
<li>原理：<ol>
<li><strong>位数组</strong>：布隆过滤器的核心是一个很长的二进制位数组（一系列比特位），所有位初始都设置为0。</li>
<li><strong>哈希函数</strong>：选择多个独立的哈希函数（理想情况下，这些哈希函数之间的碰撞概率很低）。一般情况下，k个不同的哈希函数用于处理每个待插入的元素。</li>
<li><strong>插入操作</strong>：当一个元素要加入到布隆过滤器时，它会经过k个哈希函数的处理，每个哈希函数都会产生一个位数组的索引位置。然后，这些索引位置上的比特位都会被置为1。</li>
<li><strong>查询操作</strong>：检查某个元素是否存在于集合中时，同样将该元素通过k个哈希函数映射到位数组上，如果所有这些位置的比特位都是1，则算法会报告该元素“可能”在集合中；如果有任何一个位置是0，则可以确定该元素肯定不在集合中。</li>
</ol>
</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务基本特性ACID"><a href="#事务基本特性ACID" class="headerlink" title="事务基本特性ACID"></a>事务基本特性ACID</h4><p>事务的ACID特性是数据库管理系统中保证<strong>数据一致性</strong>和<strong>可靠性</strong>的四个基本原则，它们分别是：</p>
<ol>
<li><strong>原子性（Atomicity）</strong>： 原子性确保事务是不可分割的工作单位。这意味着一个事务中的所有操作要么全部成功执行，要么全部不执行。如果事务中的任何一部分操作失败，则整个事务都会被回滚，仿佛从未开始过一样，以此来保持数据库的一致性状态。</li>
<li><strong>一致性（Consistency）</strong>： 一致性保证事务执行前后，数据库从一种一致状态转换到另一种一致状态。在事务开始之前和结束之后，数据库的完整性约束不会被破坏。例如，如果有一个规则说账户余额不能为负数，那么一致性就会确保事务结束后所有账户余额都是非负的。</li>
<li><strong>隔离性（Isolation）</strong>： 隔离性要求在并发环境中，多个事务同时执行时，每个事务好像在单独、序列化执行一样，彼此之间互不影响。不同的<strong>隔离级别</strong>（如读未提交、读已提交、可重复读、串行化）提供了不同程度的事务隔离，同时也会影响并发性能。</li>
<li><strong>持久性（Durability）</strong>： 持久性意味着一旦事务被提交，它对数据库的更改就是永久性的，即使系统发生故障（如断电、崩溃等），这些更改也不会丢失。为了确保这一点，数据库系统通常会采用日志或其他机制来记录事务的更改，并在系统恢复时根据日志重做或回滚事务</li>
</ol>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><ul>
<li>读未提交：最低的隔离级别，一个事务可以读到另一个事务修改但未提交的数据，可能导致“<strong>脏读</strong>”</li>
<li>读已提交：一个事务只能读取其他事务已经提交的数据（不提交看不到），避免了脏读，但可能出现“<strong>不可重复读</strong>”。</li>
<li>可重复读：<strong>在一个事务内多次读取同一数据的结果是一致的</strong>，即使其他事务在这期间对数据进行了修改或删除，但可能会遇到“<strong>幻读</strong>”。例如其他事务在这两次查询之间插入了新记录，导致第二次查询看到了第一次查询没有的新行。</li>
<li><strong>串行化（Serializable）</strong>：最高级别的隔离，通过完全<strong>序列化事务的执行</strong>，避免了脏读、不可重复读和幻读，但性能开销最大。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻影读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">读已提交</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<h4 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h4><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<ul>
<li><strong>修改丢失</strong>：后面事务修改的值覆盖了前面事务修改后的值</li>
<li><strong>脏读</strong>：A 事务修改数据未提交，B 事务读取该数据，就是脏数据（A 可能回滚）</li>
<li><strong>不可重复读（关注的是修改）</strong>：A 事务读取某数据，B 事务修改该数据并提交，A 事务再次读取该数据，出现数据不一致情况</li>
<li><strong>幻读（关注的是插入）</strong>：在同一事务内，两次查询同一个范围的数据，由于其他事务在这两次查询之间插入了新记录，导致第二次查询看到了第一次查询没有的新行</li>
</ul>
<h3 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h3><h4 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h4><ul>
<li>能用数字就不要用字符串<ul>
<li>支持数据库中数学运算，无需进行数据类型转换</li>
<li>占用的存储空间更少</li>
<li>索引更小，占用的空间较少，查询更快</li>
<li>更适合范围查询（如 <code>WHERE price BETWEEN 100 AND 200</code>）</li>
<li>排序比字符串类型快</li>
<li>特别是在处理大量数据和执行复杂查询时，优势更加明显</li>
</ul>
</li>
<li>尽可能使用小的类型，比如：用<code>bit</code>存布尔值，用<code>tinyint</code>存枚举值</li>
<li>长度固定的字符串字段，用<code>char</code>类型。字段值为空，也会分配定义长度的存储空间。除非字段定义不为空，否则推荐使用 <code>varchar</code> </li>
<li>长度可变的字符串字段，用<code>varchar</code>类型。字段值为空，不会分配存储空间。灵活性和空间效率更好</li>
<li>金额字段用 <code>long</code>类型</li>
<li>字段尽量 <code>NOT NULL</code>，给一个默认值。但像备注、描述、评论之类的可以设置为 NULL</li>
</ul>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul>
<li><p>避免使用 <code>select *</code>，应按需指定要返回的字段 </p>
</li>
<li><p>先缩小查询范围，再范围内操作</p>
</li>
<li><p>使用 <code>union all</code>代替<code>union</code>，后者会去重，不管数据集是否存在重复。如果需要去重，也可以在后端代码中去重</p>
</li>
<li><p>小表驱动大表</p>
<ul>
<li>用小表的数据集驱动大表的数据集</li>
<li><code>in</code> ：会优先执行 in 里面的<code>子查询语句</code>，然后再执行 in 外面的语句。**<code>in</code> 适用于左边大表，右边小表。**</li>
<li><code>exists</code>：优先执行 exists 左边的语句（即主查询语句）。然后把它作为条件，去跟右边的语句匹配。**<code>exists</code> 适用于左边小表，右边大表。**</li>
</ul>
</li>
<li><p>批量插入：建立一次连接，批量插入数据，注意每批数据量也要控制，不能太多</p>
</li>
<li><p>使用 <code>limit</code></p>
<ul>
<li>限定返回数据量，例如加上分页功能，而不是一次性返回大量数据</li>
<li>判断数据是否存在，使用 <code>limit 1</code> 而不是 <code>select count</code></li>
</ul>
</li>
<li><p>分页：在查询数据时，为了避免一次性返回过多的数据影响接口性能，我们一般会对查询接口做分页处理</p>
</li>
<li><p>使用 <code>join</code> 联表查询，代替子查询</p>
<ul>
<li>left join：以左边的表为基准，遍历右侧的表，查找符合条件的数据</li>
<li>right join：同理</li>
<li>inner join：求两个表交集的数据</li>
<li>如果能用<code>inner join</code>的地方，尽量少用 <code>left join</code></li>
<li>为联表的字段创建索引</li>
</ul>
</li>
<li><p>join的表不宜过多: 阿里巴巴开发者手册的规定，join表的数量不应该超过<code>3</code>个</p>
</li>
</ul>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ul>
<li><p>使用 <code>explain</code> 查看 sql 执行计划：查看是否用到了索引，用到了哪个索引</p>
</li>
<li><p>控制索引的数量</p>
<ul>
<li>阿里巴巴的开发者手册中规定，单表的索引数量应该尽量控制在<code>5</code>个以内，并且单个索引中的字段数不超过<code>5</code>个</li>
<li>删除无用的单个索引</li>
<li>创建复合索引，代替多个单个索引。但要注意：复合索引使用时要符合『最左前缀原则』</li>
</ul>
</li>
<li><p>在 where 、 order by、group by 涉及的列上建立索引</p>
</li>
<li><p>复合索引：联合索引的“<strong>最左前缀原则</strong>”，只有当查询条件使用了联合索引中最左侧的一个字段时，索引才会被有效利用</p>
<ul>
<li>联合索引有效：a，a和b，a和b和c</li>
<li>联合索引无效：b，c，b和c，a和c</li>
</ul>
</li>
<li><p>where 子句中对字段 is null 改为默认值，可利用到索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">is</span> <span class="keyword">null</span> </span><br><span class="line">改为</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>避免在 where 子句中使用 <code>!=</code> 或 <code>&lt;&gt;</code> 操作符：可以转换为全部减去等于情况的数据</p>
</li>
<li><p>避免在 where 子句中使用 or，特别是一个字段有索引，一个字段没有索引。索引将失效</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">or</span> Name <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span></span><br><span class="line"></span><br><span class="line">改成</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> Name <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>in 连续值，改成 between and 。索引效率更高</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>左模糊查询会导致索引失效</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%abc%&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不要在 where 中的 &#x3D; 左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> <span class="built_in">substring</span>(name,<span class="number">1</span>,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"></span><br><span class="line">改为：</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;abc%&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志</p>
</li>
<li><p>对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。</p>
</li>
<li><p>select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的</p>
</li>
<li><p>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写</p>
</li>
<li><p>尽量避免大事务操作，提高系统并发能力</p>
</li>
<li><p>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理</p>
</li>
</ul>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ul>
<li><p><code>create [TEMPORARY] table xxx as select 语句</code>：以 select 语句输出结果为输入，创建临时表</p>
</li>
<li></li>
</ul>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="默认事务隔离级别？"><a href="#默认事务隔离级别？" class="headerlink" title="默认事务隔离级别？"></a>默认事务隔离级别？</h4><p>MySQL InnoDB 存储引擎的事务默认隔离级别是 <strong>可重复度 Repeatable Read</strong></p>
<h4 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h4><p>在 MySQL InnoDB 存储引擎中，索引数据采用B+树数据结构，具体分为 2 种：</p>
<h5 id="聚簇索引（Clustered-Index）-主键索引"><a href="#聚簇索引（Clustered-Index）-主键索引" class="headerlink" title="聚簇索引（Clustered Index）- 主键索引"></a>聚簇索引（Clustered Index）- 主键索引</h5><p>如果一个表定义了主键，InnoDB会使用主键作为聚簇索引。在这种情况下，叶子节点直接存储数据记录。也就是说，数据行实际存储在叶子节点中，每个叶子节点包含了表中的<strong>实际数据行</strong>，因此在聚簇索引中，索引即数据，数据即索引。这种设计使得按主键查询非常高效</p>
<h5 id="二级索引（Secondary-Index）-辅助索引"><a href="#二级索引（Secondary-Index）-辅助索引" class="headerlink" title="二级索引（Secondary Index）- 辅助索引"></a>二级索引（Secondary Index）- 辅助索引</h5><p>对于非主键的索引，如唯一索引或者其他普通索引，这些索引被称为二级索引。在二级索引中，叶子节点不直接存储完整的数据记录，而是存储指向相应行的聚簇索引键（通常是主键的值）。当通过二级索引来查询数据时，InnoDB首先通过二级索引找到对应的主键值，然后使用这个主键值去聚簇索引中查找实际的数据行，这个过程称为<strong>回表查询</strong></p>
<h4 id="MyISAM-和-InnoDB-的区别"><a href="#MyISAM-和-InnoDB-的区别" class="headerlink" title="MyISAM 和 InnoDB 的区别"></a>MyISAM 和 InnoDB 的区别</h4><ul>
<li><strong>MyISAM</strong> 不支持<strong>事务、外键、行级锁</strong>（只有表级锁）</li>
<li><strong>InnoDB</strong> 支持事务处理（ACID兼容），可以进行提交（commit）、回滚（rollback）操作，适合需要数据一致性和完整性的应用程序，如银行系统、金融应用</li>
<li><strong>InnoDB</strong> 支持行级锁，这意味着在更新操作时，只会锁定需要修改的行，不会阻塞其他行的并发访问</li>
<li><strong>MyISAM</strong> 的索引文件和数据文件是分开的。<strong>InnoDB</strong> 的主键索引（聚簇索引）中包含实际数据，所以索引和数据在一块。对于二级索引来说，则是分开的</li>
</ul>
<h4 id="MySQL的索引有哪些"><a href="#MySQL的索引有哪些" class="headerlink" title="MySQL的索引有哪些"></a>MySQL的索引有哪些</h4><ul>
<li><strong>B+树 索引</strong><ul>
<li>是MySQL InnoDB 存储引擎的索引类型</li>
</ul>
</li>
<li><strong>哈希索引</strong><ul>
<li>哈希索引能以 O(1) 时间进行查找，但是失去了有序性</li>
<li>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找</li>
</ul>
</li>
<li><strong>全文索引</strong><ul>
<li>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE</li>
<li>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射</li>
<li>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引</li>
</ul>
</li>
<li><strong>空间数据索引</strong><ul>
<li>从 MySQL 5.7 版本开始，InnoDB 存储引擎支持空间数据索引(R-树)，可以用于<strong>地理数据</strong>存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询</li>
</ul>
</li>
</ul>
<h4 id="COUNT-、COUNT-0-、和COUNT-id-的区别"><a href="#COUNT-、COUNT-0-、和COUNT-id-的区别" class="headerlink" title="COUNT(*)、COUNT(0)、和COUNT(id)的区别"></a>COUNT(*)<code>、</code>COUNT(0)<code>、和</code>COUNT(id)的区别</h4><ol>
<li><strong>COUNT(*)</strong>:<ul>
<li><code>COUNT(*)</code>会计算表中的所有行，包括那些具有NULL值的行。它是SQL标准中用于<strong>统计行数的推荐方式</strong>。</li>
<li>在InnoDB存储引擎中，<code>COUNT(*)</code>通常是非常高效的，因为它可以直接从存储引擎的<strong>行计数器中获取行数，而不必扫描整个表</strong>。</li>
<li>不管表中是否有主键或索引，它都能准确快速地给出结果。</li>
</ul>
</li>
<li><strong>COUNT(0)</strong>:<ul>
<li><code>COUNT(0)</code>或<code>COUNT(1)</code>在行为上通常与<code>COUNT(*)</code>相同，都返回表中的行数。</li>
<li>早期的一些资料可能会指出<code>COUNT(0)</code>或<code>COUNT(1)</code>相比<code>COUNT(*)</code>在某些数据库系统中更高效，因为它们只计数一个固定值，而不是访问每一列。然而，在现代的MySQL尤其是InnoDB存储引擎中，这种差异通常不存在，因为优化器能够识别这些情况并进行相应的优化。</li>
<li>使用<code>COUNT(0)</code>或<code>COUNT(1)</code>而非<code>COUNT(*)</code>更多是基于习惯或是对历史性能差异的误解。</li>
</ul>
</li>
<li><strong>COUNT(id)</strong>:<ul>
<li>当<code>id</code>是表的一个列名，特别是当它是主键时，<code>COUNT(id)</code>的行为也类似于<code>COUNT(*)</code>，统计表中的所有行。</li>
<li>但是，与<code>COUNT(*)</code>相比，如果<code>id</code>列上有索引，尤其是在覆盖索引的情况下，理论上<code>COUNT(id)</code>可能在某些数据库系统中表现得更快，因为数据库可以直接从索引中计数而无需访问表数据。然而，在InnoDB中，由于聚簇索引的设计，这种差异通常不明显。</li>
<li><strong>如果<code>id</code>列允许NULL值，<code>COUNT(id)</code>将不计算那些<code>id</code>为NULL的行，这是它与<code>COUNT(*)</code>的主要区别。</strong></li>
</ul>
</li>
</ol>
<h4 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h4><p>全称Multi-Version Concurrency Control，即<strong>多版本并发控制</strong>。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p>
<h4 id="InnoDB引擎实现MVCC的3个基础点"><a href="#InnoDB引擎实现MVCC的3个基础点" class="headerlink" title="InnoDB引擎实现MVCC的3个基础点"></a>InnoDB引擎实现MVCC的3个基础点</h4><h5 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h5><p><code>DB_ROW_ID</code>是数据库默认为该行记录生成的<strong>隐藏主键</strong>；<code>DB_TRX_ID</code>是当前操作该记录的<strong>事务ID</strong>； 而<code>DB_ROLL_PTR</code>是一个<strong>回滚指针</strong>，用于配合undo日志，指向上一个旧版本</p>
<h5 id="Undo-Log（回滚日志）"><a href="#Undo-Log（回滚日志）" class="headerlink" title="Undo Log（回滚日志）"></a>Undo Log（回滚日志）</h5><ul>
<li><p>Undo Log在MySQL的InnoDB存储引擎中主要用于<strong>记录事务过程中对数据的修改信息</strong>，以便在事务失败需要回滚时能够恢复到事务开始前的状态</p>
</li>
<li><p>Undo Log 是实现 MVCC 的关键，它保存了数据的旧版本信息。每当事务更新一行数据时，InnoDB 不会直接覆盖原数据，而是将更改记录在 Undo Log 中，并更新该行的 <code>DB_TRX_ID</code> 和 <code>DB_ROLL_PTR</code>。这样，通过 <code>DB_ROLL_PTR</code> 可以追踪到该行数据的多个历史版本。在需要根据事务的可见性规则回溯历史版本时，Undo Log 起着至关重要的作用</p>
</li>
<li><p>Undo Log主要记录以下类型的操作日志：</p>
<ol>
<li><strong>INSERT操作</strong>：当一个事务执行INSERT操作时，Undo Log会记录一条逻辑日志来表示相反的操作，即一个DELETE记录，这样在事务回滚时可以根据这条记录删除插入的新记录，恢复到事务开始前的状态。</li>
<li><strong>UPDATE操作</strong>：对于UPDATE操作，Undo Log会记录一条或多条逻辑日志，表示将数据从更新后的状态还原到更新前的状态。也就是说，如果一行数据被更新，Undo Log中会记录一条相反的UPDATE操作，使用更新前的值覆盖更新后的值，确保在回滚时能恢复原值。</li>
<li><strong>DELETE操作</strong>：当执行DELETE操作时，Undo Log会记录一个INSERT记录，包含被删除数据的完整信息。这样在事务回滚时，可以通过Undo Log中的INSERT记录重新插入这些数据，实现撤销删除的效果。</li>
</ol>
</li>
</ul>
<h5 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h5><ul>
<li><p>ReadView 理解成一种快照</p>
</li>
<li><p>在 MySQL 的 InnoDB 存储引擎中，ReadView 用于实现事务的隔离性，尤其是对于“可重复读”（Repeatable Read）隔离级别的支持</p>
</li>
<li><p>当一个事务在可重复读隔离级别下开始时，InnoDB 会创建一个 ReadView，这个 ReadView 记录了在该事务视图下，其他活跃事务的 ID 列表以及事务的活跃状态</p>
</li>
<li><p>ReadView 实际上提供了一个数据的快照视图，确保了在同一事务内的多次查询看到的数据是一致的，即使其他事务在这期间对数据进行了修改或插入</p>
</li>
<li><p>这意味着在可重复读隔离级别下，事务开始时能看到的数据版本，在事务期间不会因其他事务的提交而改变，从而避免了不可重复读的现象</p>
</li>
</ul>
<h4 id="锁的类型有哪些"><a href="#锁的类型有哪些" class="headerlink" title="锁的类型有哪些"></a>锁的类型有哪些</h4><h5 id="共享锁-简称S锁-和排他锁-简称X锁"><a href="#共享锁-简称S锁-和排他锁-简称X锁" class="headerlink" title="共享锁(简称S锁)和排他锁(简称X锁)"></a><strong>共享锁</strong>(简称S锁)和<strong>排他锁</strong>(简称X锁)</h5><ul>
<li><p><strong>读锁</strong>是共享锁，可以通过<code>lock in share mode</code>实现，这时候<strong>只读不写</strong></p>
<ul>
<li>使用 <code>LOCK IN SHARE MODE</code> 必须在一个事务中，因为锁是在事务的上下文中维护的</li>
<li><strong>共享锁之间是共存的</strong>，但与排他锁（如 <code>FOR UPDATE</code> 产生的锁）冲突，如果某行数据已经被加了排他锁，试图加共享锁的事务将需要等待</li>
<li>查询结果为多条记录时，MySQL 的 InnoDB 存储引擎会为每一条匹配的记录分别加上一个共享锁，而不是对所有结果集加一个整体的共享锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- 查询商品ID为123的库存，并加上共享锁</span></span><br><span class="line"><span class="keyword">SELECT</span> quantity <span class="keyword">FROM</span> inventory <span class="keyword">WHERE</span> product_id <span class="operator">=</span> <span class="number">123</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="comment">-- 此处可以根据查询结果进行一些逻辑判断，但不修改数据</span></span><br><span class="line"><span class="comment">-- ...</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>写锁</strong>是排它锁，它会<strong>阻塞其它写锁和读锁</strong></p>
<ul>
<li>当事务需要更新（包括INSERT、UPDATE、DELETE操作）一行数据时，会获取该行的排他锁。一旦一个事务对某一行持有了排他锁，其他任何事务都不能再对该行加任何类型的锁，不论是共享锁还是排他锁，从而确保了该事务可以独占进行写操作</li>
<li>使用 <code>select ... for update</code>，会为结果集中每一行添加排它锁</li>
</ul>
</li>
</ul>
<h5 id="表锁和行锁"><a href="#表锁和行锁" class="headerlink" title="表锁和行锁"></a>表锁和行锁</h5><ul>
<li><p><strong>表锁</strong>：</p>
<ul>
<li><p>表锁既可以是共享锁，也可以是排它锁</p>
</li>
<li><p>使用<code>LOCK TABLES xxx read;</code>申请表的共享锁，但应谨慎使用，可以考虑行级锁来满足需求。操作完成后使用 <code>UNLOCK TABLES</code> 来释放锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 这里的 table_name 是你要对其申请共享锁的表名。这条命令会使得当前会话能够读取表中的数据，同时阻止其他会话对表进行写操作（例如 <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span>, 或 <span class="keyword">INSERT</span>），但不会阻止其他会话也获取共享锁来读取数据</span><br><span class="line">LOCK TABLES table_name READ; </span><br><span class="line"></span><br><span class="line"># 释放锁</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>alter table xxx</code> 或者 <code>LOCK TABLES table_name WRITE;</code>申请表的排它锁，谨慎使用</p>
</li>
</ul>
</li>
<li><p><strong>行锁</strong>：</p>
<ul>
<li>行锁是数据库中最细粒度的锁，<strong>锁定特定的行</strong>。由于锁的范围小，可以有效减少锁之间的冲突，提高数据库的并发处理能力</li>
<li>行锁既可以是共享锁，也可以是排他锁</li>
<li>使用 <code>SELECT ... LOCK IN SHARE MODE</code>，会为查询结果集中的每一行加上<strong>共享锁</strong>，阻止其他事务对这些行进行修改，但允许其他事务继续读取（获取共享锁）</li>
<li>使用 <code>select ... for update</code> ，会为查询结果集中的每一行加上行锁，是排它锁</li>
</ul>
</li>
</ul>
<h5 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h5><ul>
<li><p>悲观锁假定多线程或事务之间的数据竞争总会发生，因此在数据进行处理前就将其锁定，以防止并发修改</p>
</li>
<li><p>在数据库中，悲观锁通常通过显式地使用锁机制来实现，比如 InnoDB 引擎中的 <code>SELECT ... FOR UPDATE</code> 或 <code>SELECT ... LOCK IN SHARE MODE</code>。这些操作会实际地在数据库层面为数据行加上锁</p>
</li>
</ul>
<h6 id="通过-for-update-实现悲观锁"><a href="#通过-for-update-实现悲观锁" class="headerlink" title="通过 for update 实现悲观锁"></a>通过 <code>for update</code> 实现悲观锁</h6><ul>
<li>如果没有查询条件，则会加表锁，而不是行锁</li>
<li>行锁必要条件：必须有查询条件 &amp; 查询字段有索引 &amp; 索引有效</li>
<li>查询字段可以有多个，必须保证索引有效，也就是字段都建立单个索引或有复合索引</li>
<li>返回多条数据时，如果行锁有效，则会为每条数据生成一个行锁，而不是生成一个整体锁，且是排它锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 查询商品ID为123的商品，并对其进行锁定，防止其他事务修改。product_id 字段必须创建索引，否则锁表而不是锁行</span></span><br><span class="line"><span class="keyword">SELECT</span> quantity <span class="keyword">FROM</span> inventory <span class="keyword">WHERE</span> product_id <span class="operator">=</span> <span class="number">123</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 根据查询结果决定是否扣减库存，这里简化处理，直接扣减1</span></span><br><span class="line"><span class="keyword">UPDATE</span> inventory <span class="keyword">SET</span> quantity <span class="operator">=</span> quantity <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> product_id <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<h6 id="通过版本号或时间戳实现乐观锁"><a href="#通过版本号或时间戳实现乐观锁" class="headerlink" title="通过版本号或时间戳实现乐观锁"></a>通过版本号或时间戳实现乐观锁</h6><ul>
<li><p>乐观锁的核心思想是「<strong>先操作后验证</strong>」</p>
</li>
<li><p>乐观锁并不会在数据读取时立即进行锁定，而是在数据更新时检查数据是否被其他事务修改过，以此决定是否进行更新。这种方式降低了锁的开销，提高了系统的并发性能，尤其适合读多写少的场景</p>
</li>
<li><p>乐观锁常见的实现方法之一是通过版本控制（Versioning）或时间戳（Timestamp）字段</p>
<ol>
<li><strong>版本号</strong>：在表中添加一个额外的列，通常是整数类型，作为版本号。当数据首次被创建时，版本号初始化为1。每次数据更新时，除了更新实际的数据字段，还会将版本号加1。在执行更新操作前，会先检查当前版本号是否与读取时的版本号相匹配，如果匹配则更新成功并递增版本号；如果不匹配，说明数据已被其他事务修改，更新操作失败。</li>
<li><strong>时间戳</strong>：与版本号类似，但使用时间戳作为比较依据。更新时检查当前记录的时间戳是否与读取时相同，不同则拒绝更新</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 查询</span><br><span class="line"><span class="keyword">SELECT</span> id, title, content, version <span class="keyword">FROM</span> posts <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"># 其它操作xxxxxx</span><br><span class="line"></span><br><span class="line"># 更新</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 再次查询文章以获取最新版本号</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> posts <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">123</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在应用层，比较版本号</span></span><br><span class="line">IF (客户端缓存的版本号 <span class="operator">=</span><span class="operator">=</span> 查询到的版本号) &#123;</span><br><span class="line">    <span class="comment">-- 执行更新</span></span><br><span class="line">    <span class="keyword">UPDATE</span> posts <span class="keyword">SET</span> title <span class="operator">=</span> <span class="string">&#x27;新标题&#x27;</span>, content <span class="operator">=</span> <span class="string">&#x27;新内容&#x27;</span>, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">123</span> <span class="keyword">AND</span> version <span class="operator">=</span> 客户端缓存的版本号;</span><br><span class="line">&#125; <span class="keyword">ELSE</span> &#123;</span><br><span class="line">    <span class="comment">-- 版本号不匹配，抛出异常或重试逻辑</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line">    <span class="comment">-- 可能的处理逻辑：提示用户数据已更新，请刷新页面重试</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h4><p>MySQL主从复制是一种数据库管理技术，用于将数据从一个MySQL服务器（称为主服务器或Master）自动复制到一个或多个其他MySQL服务器（称为从服务器或Slave），以实现数据冗余、提高可用性和读取性能。这一过程涉及以下4个关键组件和步骤：</p>
<ol>
<li><strong>二进制日志（Binary Log）</strong>: 主服务器开启二进制日志记录功能，它会记录所有<strong>表和数据的增删改</strong>操作（如INSERT、UPDATE、DELETE、truncate table 以及CREATE TABLE、ALTER TABLE、drop table等，SELECT 操作默认不会记录到日志中）</li>
<li><strong>Log Dump线程</strong>: 当从服务器连接到主服务器请求数据时，主服务器会启动一个Log Dump线程，该线程负责读取二进制日志并将数据发送到从服务器的I&#x2F;O线程</li>
<li><strong>I&#x2F;O线程</strong>: 在每个从服务器上，有一个I&#x2F;O线程负责与主服务器通信，读取主服务器的二进制日志，并将这些日志事件写入到从服务器上的<strong>中继日志（Relay Log）</strong></li>
<li><strong>SQL线程</strong>: 从服务器上的另一个线程——SQL线程，读取中继日志并执行其中的SQL语句，以使得从服务器的数据与主服务器保持一致</li>
</ol>
<h5 id="复制模式"><a href="#复制模式" class="headerlink" title="复制模式"></a>复制模式</h5><ul>
<li><strong>异步复制</strong>: 主服务器在执行完事务后立即返回给客户端，不等待从服务器完成复制。这是<strong>MySQL默认的复制模式</strong>，效率较高，但存在数据不一致的风险。例如提交事务后，马上通过从服务器查询数据，有可能查询不到最新数据，因为数据还没有完成复制</li>
<li><strong>半同步复制</strong>: 主服务器在至少一个从服务器确认接收到日志后（接收到binlog数据，并将其写入到relay log中）才提交事务。这种方式平衡了数据安全和性能，减少了数据丢失的风险，但在网络延迟高或从服务器故障时会影响主服务器的响应速度</li>
<li><strong>全同步复制</strong>: 主服务器在所有从服务器确认接收到日志并完成复制后才提交事务。这种模式数据安全性最高，但性能较差，特别是在从服务器数量多或网络延迟高的情况下</li>
</ul>
<h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h5><p>主从复制常用于实现读写分离，即写操作（增删改）集中在主服务器上，而读操作（查询）分散到从服务器上，以此减轻主服务器的压力，提高系统的读取能力和可用性</p>
<h5 id="配置与管理"><a href="#配置与管理" class="headerlink" title="配置与管理"></a>配置与管理</h5><p>配置MySQL主从复制涉及在主服务器上设置二进制日志，在从服务器上配置连接主服务器的信息，以及启动复制进程。管理方面，需定期检查复制状态，监控复制延迟，并对复制链路故障进行及时处理</p>
<h4 id="MySQL读写分离方案"><a href="#MySQL读写分离方案" class="headerlink" title="MySQL读写分离方案"></a>MySQL读写分离方案</h4><p>搭建一主多从的MySQL集群</p>
<ul>
<li><strong>原理</strong>：设置一个主数据库（Master）处理所有写操作，并通过MySQL的复制功能同步数据到多个从数据库（Slave）。从数据库用于处理读请求</li>
<li><strong>优点</strong>：简单易行，能有效分担主数据库的读取压力，提高系统整体的读取性能</li>
<li><strong>缺点</strong>：配置和维护相对复杂，数据同步存在延迟，可能导致数据不一致</li>
</ul>
<h5 id="方案一、dynamic-datasource-使用动态数据源框架"><a href="#方案一、dynamic-datasource-使用动态数据源框架" class="headerlink" title="方案一、dynamic datasource 使用动态数据源框架"></a>方案一、dynamic datasource 使用动态数据源框架</h5><ul>
<li>支持 <strong>数据源分组</strong> ，适用于多种场景 纯粹多库 读写分离 一主多从 混合模式。</li>
<li>支持数据库敏感配置信息 <strong>加密(可自定义)</strong> ENC()。</li>
<li>支持每个数据库独立初始化表结构schema和数据库database。</li>
<li>支持无数据源启动，支持懒加载数据源（需要的时候再创建连接）。</li>
<li>支持 <strong>自定义注解</strong> ，需继承DS(3.2.0+)。</li>
<li>提供并简化对Druid，HikariCp，BeeCp,Dbcp2的快速集成。</li>
<li>提供对Mybatis-Plus，Quartz，ShardingJdbc，P6sy，Jndi等组件的集成方案。</li>
<li>提供 <strong>自定义数据源来源</strong> 方案（如全从数据库加载）。</li>
<li>提供项目启动后 <strong>动态增加移除数据源</strong> 方案。</li>
<li>提供Mybatis环境下的 <strong>纯读写分离</strong> 方案。</li>
<li>提供使用 <strong>spel动态参数</strong> 解析数据源方案。内置spel，session，header，支持自定义。</li>
<li>支持 <strong>多层数据源嵌套切换</strong> 。（ServiceA &gt;&gt;&gt; ServiceB &gt;&gt;&gt; ServiceC）。</li>
<li>提供 <strong>基于seata的分布式事务方案</strong> 。</li>
<li>提供 <strong>本地多数据源事务方案。</strong></li>
</ul>
<h5 id="方案二、基于中间件的方案"><a href="#方案二、基于中间件的方案" class="headerlink" title="方案二、基于中间件的方案"></a>方案二、基于中间件的方案</h5><ul>
<li><strong>工具</strong>：ProxySQL、MaxScale等。</li>
<li><strong>原理</strong>：作为数据库的前端代理，根据SQL语句类型自动路由到主库或从库。</li>
<li><strong>优点</strong>：高性能，高可用，易于管理和监控。</li>
<li><strong>缺点</strong>：引入了额外的组件，增加了系统的复杂度</li>
</ul>
<h4 id="MySQL主从延迟问题"><a href="#MySQL主从延迟问题" class="headerlink" title="MySQL主从延迟问题"></a>MySQL主从延迟问题</h4><ol>
<li><p><strong>优化网络配置</strong>：减少主从服务器之间的网络延迟，例如使用高速网络连接，优化网络设备配置，或尽量将主从服务器<strong>部署在同一局域网</strong>内</p>
</li>
<li><p><strong>使用半同步复制</strong>：相较于默认的异步复制，半同步复制能够在一定程度上保证数据的即时同步，即在事务提交前至少有一个从节点接收并确认了日志。这可以通过设置<code>rpl_semi_sync_master_enabled</code>和<code>rpl_semi_sync_slave_enabled</code>参数来启用</p>
</li>
<li><p><strong>增强从库处理能力</strong>：提升从库的<strong>硬件配置</strong>（如CPU、内存、存储I&#x2F;O），并<strong>优化MySQL配置参数</strong>（如增加<code>innodb_buffer_pool_size</code>）以提高SQL执行效率</p>
</li>
<li><p><strong>多线程复制</strong>：MySQL 5.6及以上版本支持<strong>多线程复制</strong>，可以并行复制不同数据库或表，显著加快从库应用日志的速度。需要配置<code>slave_parallel_workers</code>参数</p>
</li>
<li><p><strong>减少主库写入压力</strong>：优化SQL语句，避免长事务，合理设计索引，使用批量插入等，减少主库的负载，从而减少产生日志的数量和频率</p>
</li>
<li><p><strong>分库分表</strong>：对大型数据库进行水平拆分或垂直拆分，可以减轻单一数据库的压力，间接降低复制延迟</p>
</li>
<li><p><strong>选择性复制</strong>：只在从库上复制必要的数据，比如只复制部分数据库或表，减少复制的数据量</p>
</li>
<li><p><strong>监控和警报</strong>：定期监控复制延迟情况，并设置延迟警报，以便及时发现并解决问题</p>
</li>
<li><p><strong>使用专门的中间件或代理</strong>：如ProxySQL等，它们可以根据策略自动路由读写请求，还可以帮助管理复制延迟问题</p>
</li>
<li><p><strong>定期维护</strong>：包括清理无用的日志、索引优化、定期重启服务等，保持数据库的健康状态</p>
</li>
</ol>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="什么是Redis，为什么用Redis"><a href="#什么是Redis，为什么用Redis" class="headerlink" title="什么是Redis，为什么用Redis"></a>什么是Redis，为什么用Redis</h4><p>Redis是一个<strong>高性能键值对存储系统</strong>。全称为Remote Dictionary Server。<strong>可用于数据库、缓存，消息队列用于发布或订阅的场景、分布式锁、分布式 ID</strong>等场景。支持网络，<strong>基于内存，可持久化</strong></p>
<ul>
<li><strong>高性能</strong>：<ul>
<li>Redis将<strong>数据存储在内存</strong>中，这使得读写操作极其快速</li>
<li>Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s （测试条件见下一节）</li>
</ul>
</li>
<li><strong>单线程模型</strong>：Redis的主线程负责处理客户端的网络请求、执行命令以及响应结果。这意味着所有命令的执行在<strong>一个线程中串行进行</strong>，避免了多线程环境下的<strong>加锁开销</strong>和<strong>上下文切换成本</strong></li>
<li><strong>I&#x2F;O多路复用</strong>：Redis利用I&#x2F;O多路复用技术监听和管理多个客户端连接。当有客户端发起请求或者数据准备好被读取时，I&#x2F;O多路复用器（如<strong>epoll</strong>）会通知Redis主线程。这意味着Redis主线程可以同时监控成千上万个连接，而不需要为每个连接分配一个单独的线程</li>
<li><strong>事件驱动</strong>：当<strong>I&#x2F;O多路复用器</strong>检测 IO 状态（如<strong>可读</strong>、<strong>可写</strong>）时，它会将这些事件放入一个<strong>事件队列</strong>中。Redis主线程会从这个队列中取出事件并逐一处理，即按顺序执行相关的读写操作。这种方式使得Redis能够在一个线程中并发处理多个客户端的I&#x2F;O请求，虽然处理本身是串行的，但因为等待I&#x2F;O的时间被有效利用，整体效率非常高</li>
<li><strong>非阻塞操作</strong>：Redis在处理网络I&#x2F;O时采用非阻塞模式，这意味着即使在数据未准备好读取或缓冲区没有空间写入时，也不会阻塞主线程。配合I&#x2F;O多路复用，主线程总能快速地检测并响应就绪的连接，保持高效运行</li>
<li>原子性<strong>：Redis的所有操作都是原子性的，同时Redis还支持对</strong>几个操作全并后的原子性执行（MULTI和EXEC）**</li>
<li><strong>持久化</strong>：Redis支持<strong>RDB, AOF</strong>等持久化方式</li>
<li><strong>基于消息队列的发布订阅</strong>：Redis的<strong>发布&#x2F;订阅</strong>功能使其可以作为一个轻量级的消息代理系统，用于实现消息队列或发布&#x2F;订阅模式的应用</li>
<li><strong>主从复制</strong>：Redis支持数据复制，可以配置主服务器和多个从服务器，实现<strong>数据备份和故障转移</strong>，增强数据的可靠性和系统的可用性</li>
<li><strong>哨兵系统&amp;故障切换</strong>：<strong>Redis Sentinel（哨兵）系统</strong>用于<strong>监控主服务器状态</strong>并在主服务器故障时自动进行故障转移</li>
<li><strong>分布式&#x2F;集群</strong>：Redis Cluster 提供了自动分割数据到多个节点的能力，实现<strong>数据分布式存储</strong>，进一步提高了可用性和可扩展性</li>
</ul>
<h4 id="支持哪些数据类型"><a href="#支持哪些数据类型" class="headerlink" title="支持哪些数据类型"></a>支持哪些数据类型</h4><ul>
<li>String、List、Set、Zset、Hash</li>
<li><strong>三种特殊的数据类型</strong> 分别是 HyperLogLogs（基数统计）， <strong>Bitmaps (位图) 和 geo（地理位置)</strong><ul>
<li><strong>HyperLogLog（超日志对数）</strong>: 用于估算集合的唯一元素数量，即使集合元素分布在多台服务器上也能高效地进行统计</li>
<li><strong>BitMap（位图）</strong>: 用于将字符串看作比特数组，可以进行位级别的操作，适合存储和计算布尔值序列</li>
<li><strong>GEO（地理空间）</strong>: 用于存储<strong>地理位置</strong>信息，并提供地理位置相关的查询操作，如<strong>查找附近的位置、计算两点距离</strong>等</li>
</ul>
</li>
</ul>
<p><strong>String（字符串）</strong>：尽管名为字符串，但它非常灵活，不仅可以存储字符串数据，也可以用来存储<strong>整数、浮点数、二进制数据</strong>（如图片、序列化对象）。你可以直接设置和获取整数值，Redis 提供了自增 (<code>INCR</code>)、自减 (<code>DECR</code>) 等命令专门用于整数值的操作。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET myInt 100    # 存储整数值</span><br><span class="line">INCR myInt      # 自增，相当于 myInt = myInt + 1</span><br></pre></td></tr></table></figure>

<p><strong>Hash（哈希）</strong>：在哈希中，你可以将整数值作为哈希表中的字段值存储。虽然主要用于关联数组（field-value pairs），但字段值完全可以是整数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET myHash key1 100    # 在哈希表 myHash 中存储整数值</span><br></pre></td></tr></table></figure>

<p><strong>List（列表）</strong> 和 <strong>Set（集合）</strong>：这两种数据结构主要用于存储多个值，无论是字符串还是整数。你可以直接将整数值添加到列表或集合中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSH myList 100     # 将整数添加到列表头部</span><br><span class="line">SADD mySet 100       # 将整数添加到集合中</span><br></pre></td></tr></table></figure>

<p><strong>Sorted Set（有序集合）</strong>：有序集合不仅存储元素，还为每个元素关联一个分数（可以是整数），用于排序。这非常适合需要根据整数值排序的场景。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD myZSet 100 member1  # 添加成员并关联一个分数（此处为整数）</span><br></pre></td></tr></table></figure>

<h4 id="Redis默认最大内存？"><a href="#Redis默认最大内存？" class="headerlink" title="Redis默认最大内存？"></a>Redis默认最大内存？</h4><p>没有限制最大内存。Redis 会持续使用可用系统内存来存储数据，直到耗尽系统资源。</p>
<h4 id="RDB和AOF是什么"><a href="#RDB和AOF是什么" class="headerlink" title="RDB和AOF是什么"></a>RDB和AOF是什么</h4><p>RDB和AOF是Redis数据库提供的两种数据持久化策略，用于确保Redis中的数据不会因为各种原因（如服务器崩溃、重启等）丢失</p>
<h5 id="RDB（Redis-Database）-全量备份（定期、手动）"><a href="#RDB（Redis-Database）-全量备份（定期、手动）" class="headerlink" title="RDB（Redis Database）- 全量备份（定期、手动）"></a>RDB（Redis Database）- 全量备份（定期、手动）</h5><p>RDB是Redis的一种快照（snapshot）持久化方式。它会<strong>定期</strong>将某个时间点的内存数据集生成一份<strong>数据快照</strong>，保存为一个二进制文件（默认命名为dump.rdb）。这个过程可以通过执行<code>SAVE</code>命令手动触发，或者通过配置让Redis周期性自动执行<code>BGSAVE</code>命令来异步执行快照保存。当Redis服务器重启时，可以通过加载这个RDB文件来恢复之前的数据状态。RDB的优点包括：</p>
<ul>
<li>快速备份和恢复：RDB文件是经过压缩的，占用空间较小，备份和恢复速度快。</li>
<li>数据一致性相对较高：如果RDB是在Redis无写操作时生成的，那么恢复后的数据状态就是一致的。</li>
<li>适合做灾难恢复和数据备份。</li>
</ul>
<h5 id="AOF（Append-Only-File）-增量备份（always、everysec和no）"><a href="#AOF（Append-Only-File）-增量备份（always、everysec和no）" class="headerlink" title="AOF（Append Only File） - 增量备份（always、everysec和no）"></a>AOF（Append Only File） - 增量备份（always、everysec和no）</h5><p>AOF则是另一种持久化策略，它会将Redis执行的每一个<strong>写操作命令追加到一个文件</strong>（默认为appendonly.aof）中。当Redis重启时，可以通过回放这个文件中的命令来重构整个数据库的内容。AOF有多种工作模式，包括always、everysec和no，通过配置决定是每次写操作后立即同步、每秒同步一次还是完全依赖操作系统来决定同步时机。AOF的优点包括：</p>
<ul>
<li>更强的数据持久性：由于记录了每一次写操作，数据丢失的风险更低，最多只会丢失一秒的数据。</li>
<li>可以通过重写机制优化AOF文件，减少其体积。</li>
<li>支持不同的fsync策略，灵活平衡数据安全和性能。</li>
</ul>
<h5 id="混合持久化-全量-增量"><a href="#混合持久化-全量-增量" class="headerlink" title="混合持久化 - 全量+增量"></a>混合持久化 - 全量+增量</h5><p>在较新的Redis版本中，还有一种结合了RDB和AOF优点的持久化策略，称为混合持久化。在这种模式下，Redis会在执行AOF重写之前，先进行一次RDB快照生成，然后在AOF文件中仅记录从RDB快照以来的增量修改。这样既利用了RDB快照快速恢复的优势，又保留了AOF的高数据完整性，同时避免了AOF文件过大的问题</p>
<h4 id="三种-AOF-写回策略"><a href="#三种-AOF-写回策略" class="headerlink" title="三种 AOF 写回策略"></a>三种 AOF 写回策略</h4><p><code>Always</code>，<strong>同步写回</strong>：每个写命令执行完，立马同步地将日志写回磁盘</p>
<p><code>Everysec</code>，<strong>每秒写回</strong>：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘</p>
<p><code>No</code>，<strong>操作系统控制的写回</strong>：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</p>
<h4 id="有哪些使用场景"><a href="#有哪些使用场景" class="headerlink" title="有哪些使用场景"></a>有哪些使用场景</h4><h5 id="热点数据的缓存"><a href="#热点数据的缓存" class="headerlink" title="热点数据的缓存"></a>热点数据的缓存</h5><p>Redis读写性能优异。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性</p>
<h5 id="限时业务"><a href="#限时业务" class="headerlink" title="限时业务"></a>限时业务</h5><p>redis中可以使用<strong>expire</strong>命令设置一个键的生存时间，到时间后redis会失效。利用这一特性可以运用在限时的 <strong>登录验证码、token、短信验证码</strong>等业务场景</p>
<h5 id="计数器相关"><a href="#计数器相关" class="headerlink" title="计数器相关"></a>计数器相关</h5><p>redis由于<strong>incrby</strong>命令可以实现<strong>原子性的递增</strong>，所以可以运用于高并发的秒杀活动、<strong>分布式ID</strong>的生成、<strong>接口限流控制</strong></p>
<h5 id="分布式锁-1"><a href="#分布式锁-1" class="headerlink" title="分布式锁"></a>分布式锁</h5><p>基于 redission 实现分布式锁，在分布式锁的场景中，主要用在比如<strong>秒杀系统</strong>等</p>
<h5 id="分布式全局-ID"><a href="#分布式全局-ID" class="headerlink" title="分布式全局 ID"></a>分布式全局 ID</h5><h5 id="事件发布-订阅"><a href="#事件发布-订阅" class="headerlink" title="事件发布&#x2F;订阅"></a>事件发布&#x2F;订阅</h5><h5 id="消息队列，异步处理"><a href="#消息队列，异步处理" class="headerlink" title="消息队列，异步处理"></a>消息队列，异步处理</h5><h4 id="字符串类型的值最大容量是多少"><a href="#字符串类型的值最大容量是多少" class="headerlink" title="字符串类型的值最大容量是多少"></a>字符串类型的值最大容量是多少</h4><p>字符串类型的值最大能存储512MB。</p>
<p>字符串类型包括：字符串、整数、浮点数、二进制</p>
<h4 id="AOF是写前日志还是写后日志？"><a href="#AOF是写前日志还是写后日志？" class="headerlink" title="AOF是写前日志还是写后日志？"></a>AOF是写前日志还是写后日志？</h4><p>AOF日志采用写后日志，即<strong>先写内存，后写日志</strong></p>
<h4 id="为什么采用写后日志？"><a href="#为什么采用写后日志？" class="headerlink" title="为什么采用写后日志？"></a><strong>为什么采用写后日志</strong>？</h4><p>Redis要求高性能，采用写日志有两方面好处：</p>
<ul>
<li><strong>避免额外的检查开销</strong>：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。</li>
<li>不会阻塞当前的写操作</li>
</ul>
<p>但这种方式存在潜在风险：</p>
<ul>
<li>如果命令执行完成，写日志之前宕机了，会丢失数据。</li>
<li>主线程写磁盘压力大，导致写盘慢，阻塞后续操作。</li>
</ul>
<h4 id="Redis-内存淘汰算法有哪些"><a href="#Redis-内存淘汰算法有哪些" class="headerlink" title="Redis 内存淘汰算法有哪些"></a>Redis 内存淘汰算法有哪些</h4><p>Redis 提供了几种内存淘汰（eviction）策略，当<strong>Redis内存使用达到预设的最大限制时</strong>，这些策略会决定哪些键值对应该被移除以释放内存空间。以下是Redis支持的主要内存淘汰算法：</p>
<ul>
<li><p><code>noeviction</code>: 不进行删除操作，只是返回错误（OOM）当内存限制达到时【不淘汰】</p>
</li>
<li><p><code>volatile-lru</code>: 从设置了过期时间的键中，选择最近最少使用的数据进行删除【有过期时间的<strong>最近最少使用</strong>，淘汰】</p>
</li>
<li><p><code>allkeys-lru</code>: 从所有键中选择最近最少使用的数据进行删除【所有中<strong>最近最少使用</strong>的，淘汰】</p>
</li>
<li><p><code>volatile-ttl</code>: 删除那些最近将要过期的键（具有更早过期时间的键）【快过期的，淘汰】</p>
</li>
<li><p><code>volatile-random</code>: 在设置了过期时间的键中随机选择数据进行删除【有过期时间的，随机淘汰】</p>
</li>
<li><p><code>allkeys-random</code>: 从所有键中随机选择数据进行删除【所有中，随机淘汰】</p>
</li>
</ul>
<p>选择哪种淘汰策略取决于应用场景的具体需求，例如，如果你希望保留活跃数据而移除不常访问的数据，可以选择LRU或LFU策略；如果你的数据中有许多键具有过期时间，可能更适合使用带有<code>volatile</code>前缀的策略。正确的配置可以帮助优化内存使用，确保Redis的高效运行。</p>
<h4 id="Redis的内存用完了会发生什么？"><a href="#Redis的内存用完了会发生什么？" class="headerlink" title="Redis的内存用完了会发生什么？"></a>Redis的内存用完了会发生什么？</h4><ol>
<li><strong>写操作失败</strong>：Redis无法再接受新的写入操作，包括设置、更新或删除键值对。任何尝试写入数据的操作都将失败，并返回错误消息。这是因为Redis已达到其配置的最大内存限制。</li>
<li><strong>读操作可能继续</strong>：尽管内存已满，读取操作（如GET、HGET等）通常仍可进行。这是因为Redis可以从磁盘上的持久化文件中加载数据，尽管这样做可能会影响性能，因为频繁的磁盘I&#x2F;O操作比内存访问慢得多。</li>
<li><strong>内存淘汰策略执行</strong>：Redis提供了多种内存淘汰策略（如volatile-lru、allkeys-lru、volatile-random、allkeys-random、volatile-ttl、noeviction等），当内存用尽时，根据配置的淘汰策略，Redis会尝试移除一些现有数据以腾出空间给新的数据使用。不同的淘汰策略有不同的数据移除逻辑，比如基于过期时间、最近最少使用（LRU）、随机等。</li>
<li><strong>性能下降</strong>：内存用尽后，Redis可能需要频繁执行内存淘汰、数据持久化到磁盘等操作，这会显著增加系统负载，降低Redis的响应速度和服务性能</li>
<li><strong>潜在的数据丢失风险</strong>：在执行某些淘汰策略时，可能会导致一些数据被删除，尤其是在使用随机淘汰策略或者数据已过期的情况下。因此，对于重要的且未持久化的数据，可能会面临丢失的风险。</li>
</ol>
<p>为了避免Redis内存用完带来的问题，通常建议：</p>
<ul>
<li>合理配置Redis的最大内存限制（<code>maxmemory</code>），根据实际应用需求和硬件资源设定</li>
<li>选择合适的内存淘汰策略，以平衡数据的缓存效率和重要性</li>
<li>定期持久化数据，确保即使Redis重启或遇到问题，数据也能够恢复</li>
<li>监控Redis的内存使用情况，及时调整策略或扩容硬件资源</li>
</ul>
<h4 id="Redis如何做内存优化"><a href="#Redis如何做内存优化" class="headerlink" title="Redis如何做内存优化"></a>Redis如何做内存优化</h4><h5 id="缩减键值对象"><a href="#缩减键值对象" class="headerlink" title="缩减键值对象"></a>缩减键值对象</h5><ul>
<li><p>缩减键（key）和值（value）的长度</p>
</li>
<li><p>key长度：如在设计键时，在完整描述业务情况下，键值越短越好</p>
</li>
<li><p>value长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入Redis。首先应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。其次在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。以JAVA为例，内置的序列化方式无论从速度还是压缩比都不尽如人意，这时可以选择更高效的序列化工具，如: <strong>protobuf</strong>，kryo等</p>
</li>
</ul>
<h5 id="配置优化"><a href="#配置优化" class="headerlink" title="配置优化"></a>配置优化</h5><ul>
<li>设定合理的<code>maxmemory</code>限制，根据实际硬件资源和应用需求配置Redis的最大可用内存。</li>
<li>选择合适的内存淘汰策略，如LRU或LFU，以高效利用内存空间。</li>
<li>开启RDB和AOF的合理持久化策略，减少内存负担，同时保证数据安全。</li>
</ul>
<h5 id="数据结构与编码优化"><a href="#数据结构与编码优化" class="headerlink" title="数据结构与编码优化"></a>数据结构与编码优化</h5><ul>
<li>选择最合适的Redis数据结构（如Strings、Hashes、Lists等），不同的数据结构有不同的内存占用和性能特点。</li>
<li>利用Redis的内部编码优化，如使用ziplist（压缩列表）代替hashtable存储小的hashes和lists，以节省内存。</li>
</ul>
<h5 id="命令处理与数据存储优化"><a href="#命令处理与数据存储优化" class="headerlink" title="命令处理与数据存储优化"></a>命令处理与数据存储优化</h5><ul>
<li>减少不必要的数据副本，例如，通过哈希（Hashes）存储相关数据而不是单独的字符串（Strings）。</li>
<li><strong>定期审查和清理不再需要的键值对，特别是过期数据</strong>。</li>
<li>使用批量操作减少网络往返，如使用<code>MGET</code>和<code>MSET</code>代替多个独立的读写操作。</li>
</ul>
<h5 id="内存碎片整理"><a href="#内存碎片整理" class="headerlink" title="内存碎片整理"></a>内存碎片整理</h5><ul>
<li>定期执行<code>MEMORY PURGE</code>命令（Redis 4.0及以上版本），帮助回收内存碎片，提高内存使用效率。</li>
<li>考虑使用Redis的内存分配器（如jemalloc）替换默认分配器，以减少内存碎片。</li>
</ul>
<h5 id="开启内存压缩"><a href="#开启内存压缩" class="headerlink" title="开启内存压缩"></a>开启内存压缩</h5><ul>
<li>Redis 6.0开始支持的LFU（Least Frequently Used）算法结合内存压缩，可以有效减少热点数据的内存占用。</li>
<li>对于大量短生命周期数据，考虑使用Redis Module如RedisBloom进行近似计算，减少实际数据存储量。</li>
</ul>
<h5 id="操作系统层面优化"><a href="#操作系统层面优化" class="headerlink" title="操作系统层面优化"></a>操作系统层面优化</h5><ul>
<li>在Linux系统上，调整<code>vm.overcommit_memory</code>设置，允许Redis在低内存情况下仍能成功执行fork操作，用于持久化和复制。</li>
<li>确保操作系统和Redis使用的内存分配器配置得当，如使用大页内存（huge pages）以减少内存管理开销。</li>
</ul>
<h5 id="硬件升级"><a href="#硬件升级" class="headerlink" title="硬件升级"></a>硬件升级</h5><ul>
<li>使用高性能的内存条，增加内存容量，尤其是对于大数据集和高吞吐量的应用。</li>
<li>考虑使用固态硬盘（SSD）加速持久化操作，减少对内存的依赖。</li>
</ul>
<h4 id="过期键的删除策略有哪些"><a href="#过期键的删除策略有哪些" class="headerlink" title="过期键的删除策略有哪些"></a>过期键的删除策略有哪些</h4><h5 id="定时删除（Timed-deletion）"><a href="#定时删除（Timed-deletion）" class="headerlink" title="定时删除（Timed deletion）"></a>定时删除（Timed deletion）</h5><p>在为键设置过期时间的同时，Redis会创建一个定时器（timer），当键的过期时间到达时，立即由定时器自动删除该键。这种方式可以确保过期键被尽快删除，但缺点是对CPU资源消耗较大，尤其是当有很多键设置有过期时间时，可能会引发大量的定时事件处理，影响服务器性能</p>
<h5 id="惰性删除（Lazy-deletion）"><a href="#惰性删除（Lazy-deletion）" class="headerlink" title="惰性删除（Lazy deletion）"></a>惰性删除（Lazy deletion）</h5><p>只有当尝试访问一个键时，Redis才会检查该键是否已过期。如果过期，则在处理这个请求之前删除该键。这种策略减少了CPU的使用，因为它只在实际访问键时才检查和删除。但是，如果大量过期键未被访问，它们会一直占用内存空间</p>
<h5 id="定期删除（Periodic-deletion）"><a href="#定期删除（Periodic-deletion）" class="headerlink" title="定期删除（Periodic deletion）"></a>定期删除（Periodic deletion）</h5><p>Redis同时采用了<strong>惰性删除和定时删除的混合策略</strong>。除了惰性删除外，Redis还维持一个后台进程，每隔一段时间（默认是每秒）执行一次，随机检查并删除一部分已过期的键。这样可以在不影响服务器主要操作的前提下，逐步释放内存中过期的键所占用的空间。定期删除的频率和每次检查的键的数量可以在配置中调整，以达到内存使用和CPU负载之间的平衡</p>
<h4 id="Redis-客户端有哪些？"><a href="#Redis-客户端有哪些？" class="headerlink" title="Redis 客户端有哪些？"></a>Redis 客户端有哪些？</h4><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson</p>
<h4 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h4><p>Redisson 是一个基于 Redis 的 Java 客户端，它提供了许多分布式服务，包括分布式锁。Redisson 的分布式锁实现原理主要依赖于 Redis 的几个特性，特别是 <strong>Lua 脚本</strong>、事务以及<strong>键的过期机制</strong>。</p>
<h4 id="Redis6-0之前的版本真的是单线程的吗"><a href="#Redis6-0之前的版本真的是单线程的吗" class="headerlink" title="Redis6.0之前的版本真的是单线程的吗?"></a>Redis6.0之前的版本真的是单线程的吗?</h4><p>Redis在处理客户端请求时,包括<strong>获取(socket读)、解析、执行、内容返回(socket写)<strong>等都是由一个顺序串行的</strong>主线程执行</strong>的,这就是所谓的 单线程.单如果严格讲,从<strong>Redis4.0</strong>之后并不是单线程,除了主线程之外,它也有后台线程在处理一些较为缓慢的操作,例如 <strong>清理脏数据</strong>, <strong>无用链接的释放</strong>, <strong>大key的删除</strong>, <strong>数据持久化</strong>bgsave,bgrewriteaof等,都是在主线程之外的<strong>子线程单独执行</strong>的</p>
<h4 id="开启多线程后，是否会存在线程并发安全问题？"><a href="#开启多线程后，是否会存在线程并发安全问题？" class="headerlink" title="开启多线程后，是否会存在线程并发安全问题？"></a>开启多线程后，是否会存在线程并发安全问题？</h4><p>Redis的<strong>多线程部分只是用来处理网络数据的读取和协议解析</strong>，<strong>键值对的读写仍然是单线程顺序执行</strong>,因此不存在线程的并发安全问题</p>
<h4 id="缓存雪崩和击穿"><a href="#缓存雪崩和击穿" class="headerlink" title="缓存雪崩和击穿"></a>缓存雪崩和击穿</h4><ul>
<li><strong>缓存雪崩</strong>指的是由于不当的缓存过期策略或缓存服务故障，导致<strong>大量缓存数据同时失效</strong>或无法访问，这使得大量请求直接涌向后端数据库，引起系统性能急剧下降，甚至服务不可用。它影响范围广泛，可能导致整个系统崩溃</li>
<li><strong>缓存击穿</strong>则是针对<strong>单个热点数据</strong>而言，当这个被频繁访问的数据在缓存中失效时，恰好有大量请求到来，所有这些请求因为无法在缓存中找到数据而直接访问数据库，给数据库带来巨大压力。与雪崩不同，击穿的影响范围相对有限，主要是针对特定的热点数据</li>
</ul>
<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><h4 id="什么是MongoDB"><a href="#什么是MongoDB" class="headerlink" title="什么是MongoDB"></a>什么是MongoDB</h4><ul>
<li>MongoDB是面向文档的NoSQL数据库（非关系型数据库），支持分布式存储</li>
<li>由<strong>C++语言</strong>编写的，以其<strong>灵活的数据模型</strong>和强大的查询功能而著称</li>
<li>常用于内容管理、实时分析、<strong>物联网</strong>（IoT）数据存储，尤其适合处理<strong>非结构化</strong>的数据</li>
</ul>
<h4 id="MongoDB的特点"><a href="#MongoDB的特点" class="headerlink" title="MongoDB的特点"></a>MongoDB的特点</h4><ul>
<li><p>数据以文档的形式存储，类似于<strong>JSON对象</strong>，这种称为<strong>BSON</strong>（Binary JSON）的<strong>二进制格式</strong>允许存储<strong>丰富的、嵌套的数据结构</strong></p>
</li>
<li><p>与传统的关系数据库不同，MongoDB<strong>不需要预先定义数据表结构</strong>。字段可以根据需要<strong>动态扩展</strong>，这使得它非常适合快速迭代和敏捷开发。但实际开发中，一个集合最好数据结构是固定或者变化少的，否则对搜索有影响</p>
</li>
<li><p>提供了丰富的查询API，包括聚合管道、地理空间查询等，支持复杂的查询操作，接近于关系数据库的查询能力</p>
</li>
<li><p>可以<strong>创建索引</strong>以提高MongoDB中的<strong>搜索性能</strong>。MongoDB文档中的任何字段都可以建立索引</p>
</li>
<li><p>支持<strong>主从复制</strong>，用来做<strong>数据备份</strong>和<strong>故障切换</strong></p>
</li>
<li><p>支持<strong>分片技术</strong>，用来实现数据<strong>分布式存储</strong></p>
</li>
</ul>
<h4 id="MongoDB与RDBMS区别"><a href="#MongoDB与RDBMS区别" class="headerlink" title="MongoDB与RDBMS区别"></a>MongoDB与RDBMS区别</h4><table>
<thead>
<tr>
<th>SQL术语&#x2F;概念</th>
<th>MongoDB术语&#x2F;概念</th>
<th>解释&#x2F;说明</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td>database</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>数据库表&#x2F;集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>数据记录行&#x2F;文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>数据字段&#x2F;域</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>table joins</td>
<td></td>
<td>表连接,MongoDB不支持</td>
</tr>
<tr>
<td>primary key</td>
<td>primary key</td>
<td>主键,MongoDB自动将_id字段设置为主键</td>
</tr>
</tbody></table>
<h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h3><h4 id="ElasticSearch是什么"><a href="#ElasticSearch是什么" class="headerlink" title="ElasticSearch是什么"></a>ElasticSearch是什么</h4><ul>
<li>Java 编写的，核心是一个<strong>基于Lucene的全文搜索引擎</strong></li>
<li>广泛应用于<strong>日志分析</strong>、应用搜索、安全分析、商业智能、<strong>物联网数据分析</strong></li>
<li><strong>隐藏了 Lucene 的复杂性</strong>，取而代之的提供一套简单一致的 <strong>RESTful API</strong>，使得数据的索引、搜索、分析等操作变得简单直观</li>
<li>Elasticsearch特别适合处理<strong>大规模数据集</strong>，无论是<strong>结构化数据</strong>（如数字、文本）还是<strong>非结构化数据</strong>（如全文本、地理空间数据）</li>
<li>提供近乎<strong>实时的搜索</strong>能力，这意味着数据一旦被索引就可以立即被搜索到，适用于需要快速响应的场景，如电子商务搜索、实时日志分析等</li>
<li>支持复杂的<strong>全文本搜索</strong>、<strong>复合查询</strong>、<strong>聚合</strong>操作、<strong>过滤</strong>、<strong>排序</strong>、<strong>分页</strong>等功能，以及高级特性如faceting（用于复杂的数据分类和统计）、percolator（持续查询机制）</li>
<li>通过<strong>数据复制</strong>机制确保数据的安全性，即使在部分节点失败的情况下也能保证服务的连续性和数据的完整性</li>
<li>通常与<strong>Logstash</strong>（<strong>数据收集与处理</strong>工具）、<strong>Kibana</strong>（<strong>数据可视化和分析</strong>平台）以及<strong>Beats</strong>（轻量级<strong>数据采集</strong>器）一起使用，形成完整的Elastic Stack（前称为<strong>ELK</strong> Stack），为数据的<strong>收集、处理、分析、可视化</strong>提供端到端的解决方案</li>
</ul>
<h4 id="和数据库的对比"><a href="#和数据库的对比" class="headerlink" title="和数据库的对比"></a>和数据库的对比</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/es-introduce-1-3.png" alt="img" style="zoom:50%;" />

<h4 id="ES中什么是复合查询？有哪些复合查询方式？"><a href="#ES中什么是复合查询？有哪些复合查询方式？" class="headerlink" title="ES中什么是复合查询？有哪些复合查询方式？"></a>ES中什么是复合查询？有哪些复合查询方式？</h4><p>在查询中会有<strong>多种条件组合的查询</strong>，在ElasticSearch中叫复合查询。它提供了5种复合查询方式：</p>
<ul>
<li>bool query(布尔查询)<ul>
<li>通过布尔逻辑将较小的查询组合成较大的查询</li>
</ul>
</li>
<li>boosting query(提高查询)<ul>
<li>不同于bool查询，bool查询中只要一个子查询条件不匹配那么搜索的数据就不会出现。而boosting query则是降低显示的权重&#x2F;优先级（即score)</li>
</ul>
</li>
<li>constant_score（固定分数查询）<ul>
<li>查询某个条件时，固定的返回指定的score；显然当不需要计算score时，只需要filter条件即可，因为filter context忽略score。</li>
</ul>
</li>
<li>dis_max(最佳匹配查询）<ul>
<li>分离最大化查询（Disjunction Max Query）指的是： 将任何与任一查询匹配的文档作为结果返回，但只将最佳匹配的评分作为查询的评分结果返回</li>
</ul>
</li>
<li>function_score(函数查询）<ul>
<li>简而言之就是用自定义function的方式来计算_score</li>
</ul>
</li>
</ul>
<h4 id="ES底层数据持久化的过程"><a href="#ES底层数据持久化的过程" class="headerlink" title="ES底层数据持久化的过程"></a>ES底层数据持久化的过程</h4><p><strong>write -&gt; refresh -&gt; flush -&gt; merge</strong></p>
<p><strong>总体过程为：写入内存缓存区、记录事务日志、写入文件系统缓存、持久化到磁盘段文件、段合并</strong></p>
<p>Elasticsearch（简称ES）的数据持久化过程涉及几个关键步骤，主要目的是确保数据的可靠存储和快速检索。下面是ES数据持久化的基本流程：</p>
<ol>
<li><p><strong>内存缓冲（In-memory Buffer）</strong>: 当新的文档被索引到Elasticsearch时，它们首先会被<strong>写入内存中的缓冲区</strong>。这个缓冲区是用来暂存待处理的文档，以便快速写入和搜索。</p>
</li>
<li><p><strong>事务日志（Translog）</strong>: 同时，所有的写操作还会被<strong>记录到事务日志</strong>（Translog）中。Translog是一个预写日志，用于确保数据的持久性和故障恢复。如果Elasticsearch在数据还没有被刷新到磁盘时遇到故障，可以通过Translog恢复数据。</p>
</li>
<li><p><strong>自动刷新（Auto-Refresh）</strong>: 默认情况下，Elasticsearch<strong>每隔一秒</strong>（可通过<code>index.refresh_interval</code>配置）会执行一次自动刷新（Refresh）操作。刷新操作并不会立即将数据写入硬盘上的段（Segment），而是将<strong>内存缓冲区中的数据写入到文件系统缓存</strong>（FileSystem Cache）。<strong>这意味着数据已经可以被搜索到，但还未完成最终的持久化到磁盘</strong>。这个过程让ES能够在近乎实时的情况下提供搜索结果。</p>
</li>
<li><p><strong>Flush操作</strong>: Flush操作负责将<strong>文件系统缓存中的数据持久化到硬盘上的段文件</strong>中，同时清空内存缓冲区和截断Translog（或将其滚动到一个新的文件）。Flush操作发生的条件可以是定时的（默认大约每<strong>30分钟一次</strong>，可通过<code>index.translog.flush_threshold_size</code>等配置调整），或者是当Translog达到一定大小时。Flush操作比Refresh更耗时，因为它涉及到实际的磁盘I&#x2F;O操作。</p>
</li>
<li><p><strong>段合并（Segment Merge）</strong>: 随着时间推移，ES会创建许多小的段文件。为了保持高效的搜索性能，ES会<strong>定期执行段合并</strong>操作，将小的段合并成更大的段，同时在这个过程中删除重复的文档、优化索引结构。这个过程也是在后台自动进行的。</p>
</li>
</ol>
<p>整个数据持久化过程设计精巧，平衡了写入速度、搜索效率和数据安全性。通过频繁的Refresh保证数据的近实时可搜索性，而Flush和Translog机制确保了数据的持久性，即使在系统崩溃时也能恢复数据。</p>
<h4 id="ES遇到什么性能问题？"><a href="#ES遇到什么性能问题？" class="headerlink" title="ES遇到什么性能问题？"></a>ES遇到什么性能问题？</h4><ol>
<li><strong>查询响应慢</strong>：查询请求延迟高，特别是在处理复杂查询或大量数据时。</li>
<li><strong>索引速度下降</strong>：数据写入速率降低，尤其是在高并发写入场景下。</li>
<li><strong>资源争抢</strong>：CPU、内存或磁盘I&#x2F;O资源紧张，导致性能瓶颈。</li>
<li><strong>集群稳定性</strong>：节点故障频繁，集群健康状况不佳。</li>
<li><strong>内存溢出</strong>：<strong>JVM堆内存不足</strong>，引发GC压力大，影响响应时间和稳定性。</li>
<li><strong>索引膨胀</strong>：由于未及时清理或优化，索引占用空间过大。</li>
</ol>
<h4 id="如何优化的？"><a href="#如何优化的？" class="headerlink" title="如何优化的？"></a>如何优化的？</h4><h5 id="硬件优化和调参"><a href="#硬件优化和调参" class="headerlink" title="硬件优化和调参"></a>硬件优化和调参</h5><ul>
<li><p><strong>硬件升级</strong>：</p>
<ul>
<li><p>CPU： 选择更多核数的更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率</p>
</li>
<li><p>内存</p>
<ul>
<li><p><strong>配置</strong>：提供足够的内存。 lucene 能够很好的利用操作系统内存来缓存索引数据，以提供快速的查询性能。<strong>一半的物理内存留给 lucene</strong>；另<strong>一半的物理内存留给 ES</strong>（<strong>JVM heap</strong>）。<em>一般建议分配给Elasticsearch的JVM堆内存不超过机器总内存的一半，这样可以确保另一半内存可以被操作系统用来做文件系统缓存，进而优化Lucene的性能。此外，出于JVM性能考虑，通常建议堆内存不要超过32GB，因为当堆内存小于32GB时，JVM可以使用对象指针压缩技术，减少内存消耗并提高CPU效率。如果确实需要分配超过32GB的堆内存，请确保你的JVM版本支持并已启用此压缩技术的对应选项。</em></p>
<p><strong>禁止 swap</strong> ：一旦允许内存与磁盘的交换，会引起致命的性能问题。可以通过在 elasticsearch.yml 中 bootstrap.memory_lock: true，以保持 JVM 锁定内存，保证 ES 的性能</p>
<p><strong>垃圾回收器</strong>： 如果使用的 JDK8+，推荐使用G1 GC</p>
</li>
</ul>
</li>
<li><p>磁盘：使用<strong>SSD</strong>存储以提升I&#x2F;O性能。现实中可采用<strong>冷热分离</strong>的思路，也就是将<strong>查询频率低</strong>的数据迁移到<strong>成本低的存储</strong>上</p>
</li>
</ul>
</li>
<li><p><strong>JVM调优</strong>：合理配置JVM堆大小，监控GC行为并适时调整相关参数，比如年轻代与老年代比例、GC策略等</p>
</li>
<li><p><strong>网络优化</strong>：确保网络带宽足够，减少网络延迟。</p>
</li>
</ul>
<h5 id="索引设计优化"><a href="#索引设计优化" class="headerlink" title="索引设计优化"></a>索引设计优化</h5><ul>
<li><strong>合理分片</strong>：根据数据量和查询需求，选择合适的分片数量。过多分片会增加管理和查询开销，过少则可能限制并行处理能力。</li>
<li><strong>使用别名</strong>：更新索引时，通过别名避免查询中断，保证服务稳定性。</li>
<li><strong>字段优化</strong>：仅索引需要查询的字段，减少不必要的索引，优化字段类型以匹配查询需求。</li>
</ul>
<h5 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h5><ul>
<li><strong>优化查询语句</strong>：避免使用过于复杂的查询，合理使用filter与query上下文，减少返回字段量。</li>
<li><strong>缓存利用</strong>：<strong>利用查询缓存</strong>，对频繁执行且结果不经常变化的查询进行缓存。</li>
</ul>
<h5 id="系统与监控"><a href="#系统与监控" class="headerlink" title="系统与监控"></a>系统与监控</h5><ul>
<li><strong>定期维护</strong>：定期执行索引优化操作，如合并小段、<strong>清理不再使用的索引</strong>。</li>
<li><strong>监控与报警</strong>：使用Elasticsearch自带或第三方监控工具，监控集群健康状态、资源使用情况，及时发现并解决问题。</li>
<li><strong>性能测试</strong>：定期进行性能基准测试，根据测试结果调整配置参数。</li>
</ul>
<h5 id="高级策略"><a href="#高级策略" class="headerlink" title="高级策略"></a>高级策略</h5><ul>
<li><strong>索引生命周期管理</strong>：利用ILM策略自动管理索引的生命周期，包括索引的创建、 rollover、shrink、delete等，以优化存储和查询性能。</li>
<li><strong>冷热分离</strong>：<strong>将活跃查询较少的旧数据迁移到低成本存储上</strong>，以降低成本同时不影响热数据的查询性能。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wangwenzhe.github.io">王文哲</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wangwenzhe.github.io/posts/6ae47d17.html">https://wangwenzhe.github.io/posts/6ae47d17.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wangwenzhe.github.io" target="_blank">王文哲的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%85%A8%E6%A0%88/">Java全栈</a></div><div class="post_share"><div class="social-share" data-image="/about/logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/1f2c54ac.html" title="加密数据如何实现模糊查询"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">加密数据如何实现模糊查询</div></div></a></div><div class="next-post pull-right"><a href="/posts/1de34d81.html" title="Java全栈-下"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java全栈-下</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/1de34d81.html" title="Java全栈-下"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-02</div><div class="title">Java全栈-下</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/about/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">王文哲</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">588</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">351</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">549</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">风雨无阻，灯火为你，星光虽微，照耀夜空。</div></div><div class="card-widget card-cheesy_pick-up_lines"><div class="card-content"><div class="item-headline"><i class="fas fa-heart" style="color:pink"></i><span>想对你说</span></div><div id="cheesy_pick-up_lines-container"></div></div></div><script data-pjax="data-pjax" src="/js/cheesy_pick-up_lines.js"></script><div class="js-pjax"><script>cheesy_pick_up_lines()</script></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Java 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">语法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.1.</span> <span class="toc-text">面向对象特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.1.2.</span> <span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3private%E6%89%80%E4%BF%AE%E9%A5%B0%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E9%9A%90%E5%BC%8F%E7%9A%84final"><span class="toc-number">1.1.3.</span> <span class="toc-text">如何理解private所修饰的方法是隐式的final</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final-%E7%B1%BB%E5%A6%82%E4%BD%95%E6%8B%93%E5%B1%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">final 类如何拓展?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E8%BD%BD%E5%90%97"><span class="toc-number">1.1.5.</span> <span class="toc-text">final方法可以被重载吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM"><span class="toc-number">1.1.6.</span> <span class="toc-text">Java 内存模型 JMM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile"><span class="toc-number">1.1.7.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84"><span class="toc-number">1.1.8.</span> <span class="toc-text">volatile是如何实现可见性的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97"><span class="toc-number">1.1.9.</span> <span class="toc-text">volatile能保证原子性吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#a-a-b-%E4%B8%8E-a-b-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.10.</span> <span class="toc-text">a &#x3D; a + b 与 a +&#x3D; b 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-0-1-0-3-%E5%B0%86%E4%BC%9A%E8%BF%94%E5%9B%9E%E4%BB%80%E4%B9%88-true-%E8%BF%98%E6%98%AF-false"><span class="toc-number">1.1.11.</span> <span class="toc-text">3*0.1 &#x3D;&#x3D; 0.3 将会返回什么? true 还是 false?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-number">1.1.12.</span> <span class="toc-text">十进制转二进制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.13.</span> <span class="toc-text">单精度浮点数存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E5%9C%A8-Switch-%E4%B8%AD%E4%BD%BF%E7%94%A8-String-%E5%90%97"><span class="toc-number">1.1.14.</span> <span class="toc-text">能在 Switch 中使用 String 吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9equals-%E5%92%8ChashCode-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.1.15.</span> <span class="toc-text">对equals()和hashCode()的理解?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try-with-resources"><span class="toc-number">1.1.16.</span> <span class="toc-text">try-with-resources</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E3%80%81finalize-%E5%92%8C-finally-%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">1.1.17.</span> <span class="toc-text">final、finalize 和 finally 的不同之处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9Ffinal%E5%B8%B8%E9%87%8F%E5%92%8C%E9%9D%9E%E7%BC%96%E8%AF%91%E6%9C%9Ffinal%E5%B8%B8%E9%87%8F"><span class="toc-number">1.1.18.</span> <span class="toc-text">编译期final常量和非编译期final常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E3%80%81StringBuffer%E4%B8%8EStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.19.</span> <span class="toc-text">String、StringBuffer与StringBuilder的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.20.</span> <span class="toc-text">接口与抽象类的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this-%E5%92%8C-super-%E5%9C%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.21.</span> <span class="toc-text">this() 和 super()在构造方法中的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9F"><span class="toc-number">1.1.22.</span> <span class="toc-text">Java移位运算符？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.4.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">Java异常类层次结构?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%9F%A5%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%8D%E5%8F%AF%E6%9F%A5%E7%9A%84%E5%BC%82%E5%B8%B8%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">可查的异常和不可查的异常区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.4.3.</span> <span class="toc-text">throw和throws的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%BA%95%E5%B1%82%EF%BC%9F-%E5%BC%82%E5%B8%B8%E8%A1%A8"><span class="toc-number">1.4.4.</span> <span class="toc-text">异常的底层？ - 异常表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.5.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.5.1.</span> <span class="toc-text">反射是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">反射的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI"><span class="toc-number">1.6.</span> <span class="toc-text">SPI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E9%9B%86%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">Java 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection"><span class="toc-number">2.1.</span> <span class="toc-text">Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Set"><span class="toc-number">2.1.1.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List"><span class="toc-number">2.1.2.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Queue"><span class="toc-number">2.1.3.</span> <span class="toc-text">Queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">2.2.</span> <span class="toc-text">Map</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%B9%B6%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">Java 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-number">3.1.</span> <span class="toc-text">并发和并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.</span> <span class="toc-text">多线程中数据安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%85%B3%E9%94%AE%E5%AD%97-synchronized"><span class="toc-number">3.2.1.</span> <span class="toc-text">同步关键字 synchronized</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BA%92%E6%96%A5%E9%94%81-ReentrantLock"><span class="toc-number">3.2.2.</span> <span class="toc-text">可重入互斥锁 ReentrantLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Atomic-%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.3.</span> <span class="toc-text">Atomic 原子变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.2.4.</span> <span class="toc-text">volatile关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CopyOnWrite%E5%AE%B9%E5%99%A8"><span class="toc-number">3.2.5.</span> <span class="toc-text">CopyOnWrite容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88-concurrent"><span class="toc-number">3.2.6.</span> <span class="toc-text">并发集合 concurrent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">3.2.7.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.2.8.</span> <span class="toc-text">分布式锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E7%9A%84"><span class="toc-number">3.3.</span> <span class="toc-text">ThreadLocal是如何实现线程隔离的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%AD%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">方法中局部变量是否存在多线程安全问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F"><span class="toc-number">3.5.</span> <span class="toc-text">有哪几种创建线程方式?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.6.</span> <span class="toc-text">线程的中断方式有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">3.7.</span> <span class="toc-text">多线程顺序控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#thread-join"><span class="toc-number">3.7.1.</span> <span class="toc-text">thread.join()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">3.7.2.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">3.7.3.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore"><span class="toc-number">3.7.4.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AsycnTool"><span class="toc-number">3.7.5.</span> <span class="toc-text">AsycnTool</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO"><span class="toc-number">4.</span> <span class="toc-text">Java IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%8A%E4%BC%A0%E8%BE%93%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E4%BB%A5%E5%AD%97%E7%AC%A6%E8%BF%98%E6%98%AF%E5%AD%97%E8%8A%82%E4%BC%A0%E8%BE%93%E7%9A%84%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">网络上传输的数据是以字符还是字节传输的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">4.2.</span> <span class="toc-text">字节流和字符流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-IO%E3%80%81NIO%E3%80%81AIO"><span class="toc-number">4.3.</span> <span class="toc-text">Java IO、NIO、AIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO"><span class="toc-number">4.3.1.</span> <span class="toc-text">NIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AIO"><span class="toc-number">4.3.2.</span> <span class="toc-text">AIO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">4.4.</span> <span class="toc-text">I&#x2F;O 多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">4.5.</span> <span class="toc-text">常见的I&#x2F;O多路复用技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.6.</span> <span class="toc-text">I&#x2F;O多路复用工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9B%B4%E6%96%B0%E5%B0%B1%E7%BB%AA%E5%88%97%E8%A1%A8%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5%E9%80%9A%E7%9F%A5%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.6.1.</span> <span class="toc-text">为什么更新就绪列表而不是直接通知应用程序?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.7.</span> <span class="toc-text">零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap%E3%80%90%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E3%80%91-write"><span class="toc-number">4.7.1.</span> <span class="toc-text">mmap【内存映射】 + write</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sendfile%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">4.7.2.</span> <span class="toc-text">Sendfile系统调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%92%8C%E8%B0%83%E4%BC%98"><span class="toc-number">5.</span> <span class="toc-text">JVM和调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.1.</span> <span class="toc-text">类加载生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%EF%BC%88Loading%EF%BC%89"><span class="toc-number">5.1.1.</span> <span class="toc-text">加载（Loading）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%EF%BC%88Verification%EF%BC%89"><span class="toc-number">5.1.2.</span> <span class="toc-text">验证（Verification）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87%EF%BC%88Preparation%EF%BC%89"><span class="toc-number">5.1.3.</span> <span class="toc-text">准备（Preparation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%EF%BC%88Resolution%EF%BC%89"><span class="toc-number">5.1.4.</span> <span class="toc-text">解析（Resolution）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88Initialization%EF%BC%89"><span class="toc-number">5.1.5.</span> <span class="toc-text">初始化（Initialization）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">5.3.</span> <span class="toc-text">类加载器的缓存机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">5.4.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-forName-%E5%92%8CClassLoader-loadClass-%E5%8C%BA%E5%88%AB"><span class="toc-number">5.5.</span> <span class="toc-text">Class.forName()和ClassLoader.loadClass()区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">5.6.</span> <span class="toc-text">JVM内存结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%86%E5%88%86"><span class="toc-number">5.7.</span> <span class="toc-text">JVM堆内存细分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">5.8.</span> <span class="toc-text">GC垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%9E%E6%94%B6%EF%BC%88%E5%AD%98%E6%B4%BB%EF%BC%89%EF%BC%9F"><span class="toc-number">5.8.1.</span> <span class="toc-text">判断一个对象是否可回收（存活）？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-number">5.8.1.1.</span> <span class="toc-text">引用计数算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">5.8.1.2.</span> <span class="toc-text">可达性分析算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">5.8.2.</span> <span class="toc-text">对象有哪些引用类型？强软弱虚引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">5.8.2.1.</span> <span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">5.8.2.2.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">5.8.2.3.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">5.8.2.4.</span> <span class="toc-text">虚引用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">5.8.3.</span> <span class="toc-text">垃圾回收算法？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4"><span class="toc-number">5.8.3.1.</span> <span class="toc-text">标记 - 清除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86"><span class="toc-number">5.8.3.2.</span> <span class="toc-text">标记 - 整理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6"><span class="toc-number">5.8.3.3.</span> <span class="toc-text">复制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">5.8.4.</span> <span class="toc-text">分代收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">5.8.4.1.</span> <span class="toc-text">新生代-复制算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3-%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">5.8.4.2.</span> <span class="toc-text">老年代-标记整理算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">5.8.5.</span> <span class="toc-text">分区收集算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMinor-GC%E3%80%81Major-GC%E3%80%81Full-GC"><span class="toc-number">5.8.6.</span> <span class="toc-text">什么是Minor GC、Major GC、Full GC?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Full-GC%E9%80%9A%E5%B8%B8%E5%9C%A8%E4%BB%A5%E4%B8%8B%E6%83%85%E5%86%B5%E4%B8%8B%E5%8F%91%E7%94%9F"><span class="toc-number">5.8.7.</span> <span class="toc-text">Full GC通常在以下情况下发生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java8-%E5%85%83%E7%A9%BA%E9%97%B4%E5%8C%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E4%BC%9A%E8%BF%9B%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">5.8.8.</span> <span class="toc-text">Java8+ 元空间区的数据是否会进行垃圾回收？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java8-%E5%85%83%E7%A9%BA%E9%97%B4%E8%A7%A6%E5%8F%91GC%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="toc-number">5.8.9.</span> <span class="toc-text">Java8+元空间触发GC条件？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hotspot%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="toc-number">5.8.10.</span> <span class="toc-text">Hotspot中有哪些垃圾回收器？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.8.10.1.</span> <span class="toc-text">Serial 收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ParNew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.8.10.2.</span> <span class="toc-text">ParNew 收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.8.10.3.</span> <span class="toc-text">Parallel Scavenge 收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.8.10.4.</span> <span class="toc-text">Serial Old 收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.8.10.5.</span> <span class="toc-text">Parallel Old 收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CMS-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.8.10.6.</span> <span class="toc-text">CMS 收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.8.10.7.</span> <span class="toc-text">G1垃圾收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ZGC%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.8.10.8.</span> <span class="toc-text">ZGC垃圾收集器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0"><span class="toc-number">5.9.</span> <span class="toc-text">JVM内存相关启动参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE"><span class="toc-number">5.9.1.</span> <span class="toc-text">基本内存配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3%E9%85%8D%E7%BD%AE"><span class="toc-number">5.9.2.</span> <span class="toc-text">新生代与老年代配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE"><span class="toc-number">5.9.3.</span> <span class="toc-text">其他高级内存配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="toc-number">5.9.4.</span> <span class="toc-text">垃圾收集器相关参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%AF%8A%E6%96%AD"><span class="toc-number">5.9.5.</span> <span class="toc-text">监控与诊断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">5.10.</span> <span class="toc-text">问题排查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%AE%BA"><span class="toc-number">5.10.1.</span> <span class="toc-text">方法论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">5.10.2.</span> <span class="toc-text">Linux定位问题的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E3%80%81%E9%98%B2%E7%81%AB%E5%A2%99%E3%80%81%E7%A3%81%E7%9B%98%E3%80%81%E5%86%85%E5%AD%98%E3%80%81%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E3%80%81%E6%97%A5%E5%BF%97"><span class="toc-number">5.10.2.1.</span> <span class="toc-text">网络、防火墙、磁盘、内存、环境变量、日志</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK%E8%87%AA%E5%B8%A6%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%9F"><span class="toc-number">5.10.3.</span> <span class="toc-text">JDK自带的工具？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#jps%E3%80%81jstack%E3%80%81jmap%E3%80%81jinfo%E3%80%81jstat"><span class="toc-number">5.10.3.1.</span> <span class="toc-text">jps、jstack、jmap、jinfo、jstat</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%EF%BC%9F"><span class="toc-number">5.10.4.</span> <span class="toc-text">Java 诊断工具Arthas？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">5.10.4.1.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.10.4.2.</span> <span class="toc-text">使用步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.10.4.3.</span> <span class="toc-text">使用示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Idea%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95-Xdebug"><span class="toc-number">5.10.5.</span> <span class="toc-text">Idea的远程调试 -Xdebug</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%96%B0%E7%89%88%E6%9C%AC"><span class="toc-number">6.</span> <span class="toc-text">Java 新版本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-8-%E7%89%B9%E6%80%A7"><span class="toc-number">6.1.</span> <span class="toc-text">Java 8 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%94%AF%E6%8C%81-default-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.1.</span> <span class="toc-text">接口支持 default 实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%94%AF%E6%8C%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.2.</span> <span class="toc-text">接口支持静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.1.3.</span> <span class="toc-text">函数式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.1.4.</span> <span class="toc-text">Lambda表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Optional"><span class="toc-number">6.1.5.</span> <span class="toc-text">Optional</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">6.1.6.</span> <span class="toc-text">类型注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">数据结构和算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80"><span class="toc-number">7.1.</span> <span class="toc-text">数据结构基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-Array"><span class="toc-number">7.1.1.</span> <span class="toc-text">数组 (Array)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8-Linked-List"><span class="toc-number">7.1.2.</span> <span class="toc-text">链表 (Linked List)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88-Stack"><span class="toc-number">7.1.3.</span> <span class="toc-text">栈 (Stack)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97-Queue"><span class="toc-number">7.1.4.</span> <span class="toc-text">队列 (Queue)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-Hash-Table"><span class="toc-number">7.1.5.</span> <span class="toc-text">哈希表 (Hash Table)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91-Tree"><span class="toc-number">7.1.6.</span> <span class="toc-text">树 (Tree)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE-Graph"><span class="toc-number">7.1.7.</span> <span class="toc-text">图 (Graph)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">7.2.</span> <span class="toc-text">算法思想</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="toc-number">7.2.1.</span> <span class="toc-text">分治算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95"><span class="toc-number">7.2.2.</span> <span class="toc-text">动态规划算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">7.2.3.</span> <span class="toc-text">贪心算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-number">7.2.4.</span> <span class="toc-text">二分法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="toc-number">7.2.5.</span> <span class="toc-text">搜索算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Backtracking-%E5%9B%9E%E6%BA%AF"><span class="toc-number">7.2.6.</span> <span class="toc-text">Backtracking(回溯)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-Bubble-Sort"><span class="toc-number">7.3.1.</span> <span class="toc-text">冒泡排序 (Bubble Sort)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Quick-Sort"><span class="toc-number">7.3.2.</span> <span class="toc-text">快速排序 (Quick Sort)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-Insertion-Sort"><span class="toc-number">7.3.3.</span> <span class="toc-text">插入排序(Insertion Sort)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-Selection-sort"><span class="toc-number">7.3.4.</span> <span class="toc-text">选择排序(Selection sort)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-Merge-Sort"><span class="toc-number">7.3.5.</span> <span class="toc-text">归并排序(Merge Sort)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F-Heap-Sort"><span class="toc-number">7.3.6.</span> <span class="toc-text">堆排序(Heap Sort)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">7.4.</span> <span class="toc-text">加密算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95"><span class="toc-number">7.4.1.</span> <span class="toc-text">摘要算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">7.4.2.</span> <span class="toc-text">对称加密算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">7.4.3.</span> <span class="toc-text">非对称加密算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.4.4.</span> <span class="toc-text">混合加密系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">7.4.5.</span> <span class="toc-text">国密算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E7%AE%97%E6%B3%95"><span class="toc-number">7.5.</span> <span class="toc-text">领域算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">7.5.1.</span> <span class="toc-text">布隆过滤器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">8.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">8.1.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7ACID"><span class="toc-number">8.1.1.</span> <span class="toc-text">事务基本特性ACID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">8.1.2.</span> <span class="toc-text">事务的隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">8.1.3.</span> <span class="toc-text">并发一致性问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E4%BC%98%E5%8C%96"><span class="toc-number">8.2.</span> <span class="toc-text">SQL 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.2.1.</span> <span class="toc-text">字段类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">8.2.2.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">8.2.3.</span> <span class="toc-text">索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">8.2.4.</span> <span class="toc-text">扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL"><span class="toc-number">8.3.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9F"><span class="toc-number">8.3.1.</span> <span class="toc-text">默认事务隔离级别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95-1"><span class="toc-number">8.3.2.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%88Clustered-Index%EF%BC%89-%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">8.3.2.1.</span> <span class="toc-text">聚簇索引（Clustered Index）- 主键索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%88Secondary-Index%EF%BC%89-%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="toc-number">8.3.2.2.</span> <span class="toc-text">二级索引（Secondary Index）- 辅助索引</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyISAM-%E5%92%8C-InnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.3.3.</span> <span class="toc-text">MyISAM 和 InnoDB 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E7%9A%84%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">8.3.4.</span> <span class="toc-text">MySQL的索引有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#COUNT-%E3%80%81COUNT-0-%E3%80%81%E5%92%8CCOUNT-id-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.3.5.</span> <span class="toc-text">COUNT(*)、COUNT(0)、和COUNT(id)的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMVCC%EF%BC%9F"><span class="toc-number">8.3.6.</span> <span class="toc-text">什么是MVCC？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E5%BC%95%E6%93%8E%E5%AE%9E%E7%8E%B0MVCC%E7%9A%843%E4%B8%AA%E5%9F%BA%E7%A1%80%E7%82%B9"><span class="toc-number">8.3.7.</span> <span class="toc-text">InnoDB引擎实现MVCC的3个基础点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5"><span class="toc-number">8.3.7.1.</span> <span class="toc-text">隐藏字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Undo-Log%EF%BC%88%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%EF%BC%89"><span class="toc-number">8.3.7.2.</span> <span class="toc-text">Undo Log（回滚日志）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ReadView"><span class="toc-number">8.3.7.3.</span> <span class="toc-text">ReadView</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">8.3.8.</span> <span class="toc-text">锁的类型有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81-%E7%AE%80%E7%A7%B0S%E9%94%81-%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81-%E7%AE%80%E7%A7%B0X%E9%94%81"><span class="toc-number">8.3.8.1.</span> <span class="toc-text">共享锁(简称S锁)和排他锁(简称X锁)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E9%94%81%E5%92%8C%E8%A1%8C%E9%94%81"><span class="toc-number">8.3.8.2.</span> <span class="toc-text">表锁和行锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">8.3.8.3.</span> <span class="toc-text">悲观锁和乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-for-update-%E5%AE%9E%E7%8E%B0%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">8.3.8.3.1.</span> <span class="toc-text">通过 for update 实现悲观锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%89%88%E6%9C%AC%E5%8F%B7%E6%88%96%E6%97%B6%E9%97%B4%E6%88%B3%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">8.3.8.3.2.</span> <span class="toc-text">通过版本号或时间戳实现乐观锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">8.3.9.</span> <span class="toc-text">MySQL主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.3.9.1.</span> <span class="toc-text">复制模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">8.3.9.2.</span> <span class="toc-text">读写分离</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="toc-number">8.3.9.3.</span> <span class="toc-text">配置与管理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%96%B9%E6%A1%88"><span class="toc-number">8.3.10.</span> <span class="toc-text">MySQL读写分离方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80%E3%80%81dynamic-datasource-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E6%A1%86%E6%9E%B6"><span class="toc-number">8.3.10.1.</span> <span class="toc-text">方案一、dynamic datasource 使用动态数据源框架</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C%E3%80%81%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">8.3.10.2.</span> <span class="toc-text">方案二、基于中间件的方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98"><span class="toc-number">8.3.11.</span> <span class="toc-text">MySQL主从延迟问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis"><span class="toc-number">8.4.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedis%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8Redis"><span class="toc-number">8.4.1.</span> <span class="toc-text">什么是Redis，为什么用Redis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.4.2.</span> <span class="toc-text">支持哪些数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E9%BB%98%E8%AE%A4%E6%9C%80%E5%A4%A7%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">8.4.3.</span> <span class="toc-text">Redis默认最大内存？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E5%92%8CAOF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.4.4.</span> <span class="toc-text">RDB和AOF是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RDB%EF%BC%88Redis-Database%EF%BC%89-%E5%85%A8%E9%87%8F%E5%A4%87%E4%BB%BD%EF%BC%88%E5%AE%9A%E6%9C%9F%E3%80%81%E6%89%8B%E5%8A%A8%EF%BC%89"><span class="toc-number">8.4.4.1.</span> <span class="toc-text">RDB（Redis Database）- 全量备份（定期、手动）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF%EF%BC%88Append-Only-File%EF%BC%89-%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD%EF%BC%88always%E3%80%81everysec%E5%92%8Cno%EF%BC%89"><span class="toc-number">8.4.4.2.</span> <span class="toc-text">AOF（Append Only File） - 增量备份（always、everysec和no）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96-%E5%85%A8%E9%87%8F-%E5%A2%9E%E9%87%8F"><span class="toc-number">8.4.4.3.</span> <span class="toc-text">混合持久化 - 全量+增量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D-AOF-%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5"><span class="toc-number">8.4.5.</span> <span class="toc-text">三种 AOF 写回策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.4.6.</span> <span class="toc-text">有哪些使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-number">8.4.6.1.</span> <span class="toc-text">热点数据的缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%90%E6%97%B6%E4%B8%9A%E5%8A%A1"><span class="toc-number">8.4.6.2.</span> <span class="toc-text">限时业务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">8.4.6.3.</span> <span class="toc-text">计数器相关</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-1"><span class="toc-number">8.4.6.4.</span> <span class="toc-text">分布式锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80-ID"><span class="toc-number">8.4.6.5.</span> <span class="toc-text">分布式全局 ID</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85"><span class="toc-number">8.4.6.6.</span> <span class="toc-text">事件发布&#x2F;订阅</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="toc-number">8.4.6.7.</span> <span class="toc-text">消息队列，异步处理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">8.4.7.</span> <span class="toc-text">字符串类型的值最大容量是多少</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E6%98%AF%E5%86%99%E5%89%8D%E6%97%A5%E5%BF%97%E8%BF%98%E6%98%AF%E5%86%99%E5%90%8E%E6%97%A5%E5%BF%97%EF%BC%9F"><span class="toc-number">8.4.8.</span> <span class="toc-text">AOF是写前日志还是写后日志？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E5%86%99%E5%90%8E%E6%97%A5%E5%BF%97%EF%BC%9F"><span class="toc-number">8.4.9.</span> <span class="toc-text">为什么采用写后日志？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">8.4.10.</span> <span class="toc-text">Redis 内存淘汰算法有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%94%A8%E5%AE%8C%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.4.11.</span> <span class="toc-text">Redis的内存用完了会发生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E5%81%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-number">8.4.12.</span> <span class="toc-text">Redis如何做内存优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%A9%E5%87%8F%E9%94%AE%E5%80%BC%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.4.12.1.</span> <span class="toc-text">缩减键值对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96"><span class="toc-number">8.4.12.2.</span> <span class="toc-text">配置优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">8.4.12.3.</span> <span class="toc-text">数据结构与编码优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BC%98%E5%8C%96"><span class="toc-number">8.4.12.4.</span> <span class="toc-text">命令处理与数据存储优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86"><span class="toc-number">8.4.12.5.</span> <span class="toc-text">内存碎片整理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E5%86%85%E5%AD%98%E5%8E%8B%E7%BC%A9"><span class="toc-number">8.4.12.6.</span> <span class="toc-text">开启内存压缩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2%E4%BC%98%E5%8C%96"><span class="toc-number">8.4.12.7.</span> <span class="toc-text">操作系统层面优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%8D%87%E7%BA%A7"><span class="toc-number">8.4.12.8.</span> <span class="toc-text">硬件升级</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">8.4.13.</span> <span class="toc-text">过期键的删除策略有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4%EF%BC%88Timed-deletion%EF%BC%89"><span class="toc-number">8.4.13.1.</span> <span class="toc-text">定时删除（Timed deletion）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4%EF%BC%88Lazy-deletion%EF%BC%89"><span class="toc-number">8.4.13.2.</span> <span class="toc-text">惰性删除（Lazy deletion）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4%EF%BC%88Periodic-deletion%EF%BC%89"><span class="toc-number">8.4.13.3.</span> <span class="toc-text">定期删除（Periodic deletion）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">8.4.14.</span> <span class="toc-text">Redis 客户端有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson"><span class="toc-number">8.4.15.</span> <span class="toc-text">Redisson</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis6-0%E4%B9%8B%E5%89%8D%E7%9A%84%E7%89%88%E6%9C%AC%E7%9C%9F%E7%9A%84%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%97"><span class="toc-number">8.4.16.</span> <span class="toc-text">Redis6.0之前的版本真的是单线程的吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8E%EF%BC%8C%E6%98%AF%E5%90%A6%E4%BC%9A%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">8.4.17.</span> <span class="toc-text">开启多线程后，是否会存在线程并发安全问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%92%8C%E5%87%BB%E7%A9%BF"><span class="toc-number">8.4.18.</span> <span class="toc-text">缓存雪崩和击穿</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MongoDB"><span class="toc-number">8.5.</span> <span class="toc-text">MongoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMongoDB"><span class="toc-number">8.5.1.</span> <span class="toc-text">什么是MongoDB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MongoDB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">8.5.2.</span> <span class="toc-text">MongoDB的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MongoDB%E4%B8%8ERDBMS%E5%8C%BA%E5%88%AB"><span class="toc-number">8.5.3.</span> <span class="toc-text">MongoDB与RDBMS区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ElasticSearch"><span class="toc-number">8.6.</span> <span class="toc-text">ElasticSearch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ElasticSearch%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.6.1.</span> <span class="toc-text">ElasticSearch是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">8.6.2.</span> <span class="toc-text">和数据库的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">8.6.3.</span> <span class="toc-text">ES中什么是复合查询？有哪些复合查询方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">8.6.4.</span> <span class="toc-text">ES底层数据持久化的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES%E9%81%87%E5%88%B0%E4%BB%80%E4%B9%88%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">8.6.5.</span> <span class="toc-text">ES遇到什么性能问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%9A%84%EF%BC%9F"><span class="toc-number">8.6.6.</span> <span class="toc-text">如何优化的？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96%E5%92%8C%E8%B0%83%E5%8F%82"><span class="toc-number">8.6.6.1.</span> <span class="toc-text">硬件优化和调参</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96"><span class="toc-number">8.6.6.2.</span> <span class="toc-text">索引设计优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">8.6.6.3.</span> <span class="toc-text">查询优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%9B%91%E6%8E%A7"><span class="toc-number">8.6.6.4.</span> <span class="toc-text">系统与监控</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%AD%96%E7%95%A5"><span class="toc-number">8.6.6.5.</span> <span class="toc-text">高级策略</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/ddd69226.html" title="Maven一文搞懂项目pom.xml配置文件setting.xml 配置项之间的关系">Maven一文搞懂项目pom.xml配置文件setting.xml 配置项之间的关系</a><time datetime="2025-06-15T14:19:06.000Z" title="发表于 2025-06-15 22:19:06">2025-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/7d3170cb.html" title="软件系统中通知公告和系统消息的区别">软件系统中通知公告和系统消息的区别</a><time datetime="2025-06-15T14:06:06.000Z" title="发表于 2025-06-15 22:06:06">2025-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/41a29295.html" title="SpringBoot下使用Redis，配置多个database数据源">SpringBoot下使用Redis，配置多个database数据源</a><time datetime="2025-06-15T14:05:49.000Z" title="发表于 2025-06-15 22:05:49">2025-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/c4ea753b.html" title="Redis-集群模式下，数据为什么都存储在database0中">Redis-集群模式下，数据为什么都存储在database0中</a><time datetime="2025-06-15T14:05:32.000Z" title="发表于 2025-06-15 22:05:32">2025-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/b2e22825.html" title="NLP">NLP</a><time datetime="2025-06-15T14:05:17.000Z" title="发表于 2025-06-15 22:05:17">2025-06-15</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 王文哲</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="/js/fishes.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start -->
      <div id="xf-MusicPlayer" data-cdnName="https://player.xfyun.club/js"  data-themeColor="xf-darkGreen"data-memory="1"></div>
<script src="https://player.xfyun.club/js/xf-MusicPlayer/js/xf-MusicPlayer.min.js"></script><!-- hexo injector body_end end --></body></html>