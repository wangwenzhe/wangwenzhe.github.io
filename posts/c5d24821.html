<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java-面试题 | 王文哲的博客</title><meta name="author" content="王文哲"><meta name="copyright" content="王文哲"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="来源https:&#x2F;&#x2F;gitee.com&#x2F;SnailClimb&#x2F;JavaGuide https:&#x2F;&#x2F;gitee.com&#x2F;shishan100&#x2F;Java-Interview-Advanced equals 与 &#x3D;&#x3D; 的区别&#x3D;&#x3D;  如果是基本类型，&#x3D;&#x3D; 表示判断它们值是否相等； 如果是引用对象，&#x3D;&#x3D; 表示判断两个对象指向的内">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-面试题">
<meta property="og:url" content="https://wangwenzhe.github.io/posts/c5d24821.html">
<meta property="og:site_name" content="王文哲的博客">
<meta property="og:description" content="来源https:&#x2F;&#x2F;gitee.com&#x2F;SnailClimb&#x2F;JavaGuide https:&#x2F;&#x2F;gitee.com&#x2F;shishan100&#x2F;Java-Interview-Advanced equals 与 &#x3D;&#x3D; 的区别&#x3D;&#x3D;  如果是基本类型，&#x3D;&#x3D; 表示判断它们值是否相等； 如果是引用对象，&#x3D;&#x3D; 表示判断两个对象指向的内">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wangwenzhe.github.io/about/logo.png">
<meta property="article:published_time" content="2021-07-08T02:02:30.000Z">
<meta property="article:modified_time" content="2025-06-15T13:17:21.892Z">
<meta property="article:author" content="王文哲">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wangwenzhe.github.io/about/logo.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wangwenzhe.github.io/posts/c5d24821.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java-面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-15 21:17:21'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/about/logo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">593</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">354</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">555</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/img/top_img.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="王文哲的博客"><span class="site-name">王文哲的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java-面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-08T02:02:30.000Z" title="发表于 2021-07-08 10:02:30">2021-07-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-15T13:17:21.892Z" title="更新于 2025-06-15 21:17:21">2025-06-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java-面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a target="_blank" rel="noopener" href="https://gitee.com/SnailClimb/JavaGuide">https://gitee.com/SnailClimb/JavaGuide</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/shishan100/Java-Interview-Advanced">https://gitee.com/shishan100/Java-Interview-Advanced</a></p>
<h2 id="equals-与-的区别"><a href="#equals-与-的区别" class="headerlink" title="equals 与 &#x3D;&#x3D; 的区别"></a>equals 与 &#x3D;&#x3D; 的区别</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzFqTyibxYauPWFYQ6d1hDR8X03ZPicdTicecXCibZfuORLhukvIrgR82C3U0Pt9KHP3ATwXDsuc8ibww8g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><strong>&#x3D;&#x3D;</strong></p>
<ul>
<li>如果是基本类型，&#x3D;&#x3D; 表示判断它们值是否相等；</li>
<li>如果是引用对象，&#x3D;&#x3D; 表示判断两个对象指向的内存地址是否相同。</li>
</ul>
<p><strong>equals</strong></p>
<ul>
<li>如果是字符串，表示判断字符串内容是否相同；</li>
<li>如果是 object 对象的方法，比较的也是引用的内存地址值；</li>
<li>如果自己的类重写 equals 方法，可以自定义两个对象是否相等。</li>
</ul>
<h2 id="final-finally-finalize-的区别"><a href="#final-finally-finalize-的区别" class="headerlink" title="final, finally, finalize 的区别"></a>final, finally, finalize 的区别</h2><ul>
<li>final 用于修饰属性，方法和类，分别表示属性不能被重新赋值，方法不可被覆盖，类不可被继承.</li>
<li>finally 是异常处理语句结构的一部分，一般以 ty-catch-finally 出现，finally 代码块表示总是被执行.</li>
<li>finalize 是 Object 类的一个方法，该方法一般由垃圾回收器来调用，当我们调用 System.gc () 方法的时候，由垃圾回收器调用 finalize () 方法，回收垃圾，JVM 并不保证此方法总被调用.</li>
</ul>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><ul>
<li>重写必须继承，重载不用。</li>
<li>重载表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）</li>
<li>重写表示子类中的方法与父类中的某个方法的名称和参数完全相同啦，通过子类实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这是面向对象编程的多态性的一种表现。</li>
<li>重写的方法修饰符大于等于父类的方法，即访问权限只能比父类的更大，不能更小，而重载和修饰符无关。</li>
<li>重写覆盖的方法中，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为不能坑爹啊哈哈～</li>
</ul>
<h2 id="两个对象的-hashCode-相同，则-equals-是否也一定为-true？"><a href="#两个对象的-hashCode-相同，则-equals-是否也一定为-true？" class="headerlink" title="两个对象的 hashCode () 相同，则 equals () 是否也一定为 true？"></a>两个对象的 hashCode () 相同，则 equals () 是否也一定为 true？</h2><p>两个对象 equals 相等，则它们的 hashcode 必须相等。如果两个对象的 hashCode () 相同，则 equals () 不一定为 true。</p>
<p><strong>hashCode 的常规协定：</strong></p>
<ul>
<li>在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。</li>
<li>两个对象的 equals () 相等，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。</li>
<li>两个对象的 equals () 不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不要求一定生成不同的整数结果。但是，为不相等的对象生成不同整数结果可以提高哈希表的性能。</li>
</ul>
<h2 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h2><ul>
<li>抽象类要被子类继承，接口要被子类实现</li>
<li>抽象类可以有构造方法，接口中不能有构造方法</li>
<li>抽象类中可以有普通成员变量，接口中没有普通成员变量，它的变量只能是公共的静态的常量</li>
<li>一个类可以实现多个接口，但是只能继承一个父类，这个父类可以是抽象类</li>
<li>接口只能做方法声明，抽象类中可以作方法声明，也可以做方法实现</li>
<li>抽象级别（从高到低）：接口 &gt; 抽象类 &gt; 实现类</li>
<li>抽象类主要是用来抽象类别，接口主要是用来抽象方法功能</li>
<li>抽象类的关键字是 abstract，接口的关键字是 interfac</li>
</ul>
<h2 id="BIO、NIO、AIO-有什么区别？"><a href="#BIO、NIO、AIO-有什么区别？" class="headerlink" title="BIO、NIO、AIO 有什么区别？"></a>BIO、NIO、AIO 有什么区别？</h2><p>这个答案来自互联网哈，个人觉得是最好理解的～</p>
<blockquote>
<ul>
<li>BIO：线程发起 IO 请求，不管内核是否准备好 IO 操作，从发起请求起，线程一直阻塞，直到操作完成。</li>
<li>NIO：线程发起 IO 请求，立即返回；内核在做好 IO 操作的准备之后，通过调用注册的回调函数通知线程做 IO 操作，线程开始阻塞，直到操作完成。</li>
<li>AIO：线程发起 IO 请求，立即返回；内存做好 IO 操作的准备之后，做 IO 操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做 IO 操作完成或者失败。</li>
</ul>
</blockquote>
<p>BIO 是一个连接一个线程。,NIO 是一个请求一个线程。,AIO 是一个有效请求一个线程。</p>
<blockquote>
<ul>
<li>BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li>
<li>NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I&#x2F;O 请求时才启动一个线程进行处理。</li>
<li>AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的 IO 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理。</li>
</ul>
</blockquote>
<h2 id="String，Stringbuffer，StringBuilder-的区别「考」"><a href="#String，Stringbuffer，StringBuilder-的区别「考」" class="headerlink" title="String，Stringbuffer，StringBuilder 的区别「考」"></a>String，Stringbuffer，StringBuilder 的区别「考」</h2><p><strong>String：</strong></p>
<ul>
<li>String 类是一个不可变的类，一旦创建就不可以修改。</li>
<li>String 是 final 类，不能被继承</li>
<li>String 实现了 equals () 方法和 hashCode () 方法</li>
</ul>
<p><strong>StringBuffer：</strong></p>
<ul>
<li>继承自 AbstractStringBuilder，是可变类。</li>
<li>StringBuffer 是线程安全的</li>
<li>可以通过 append 方法动态构造数据。</li>
</ul>
<p><strong>StringBuilder：</strong></p>
<ul>
<li>继承自 AbstractStringBuilder，是可变类。</li>
<li>StringBuilder 是非线性安全的。</li>
<li>执行效率比 StringBuffer 高。</li>
</ul>
<h2 id="JAVA-中的几种基本数据类型是什么，各自占用多少字节呢"><a href="#JAVA-中的几种基本数据类型是什么，各自占用多少字节呢" class="headerlink" title="JAVA 中的几种基本数据类型是什么，各自占用多少字节呢"></a>JAVA 中的几种基本数据类型是什么，各自占用多少字节呢</h2><table>
<thead>
<tr>
<th align="left">基本类型</th>
<th align="left">位数</th>
<th align="left">字节</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int</td>
<td align="left">32</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">16</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">64</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">8</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">16</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">32</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">64</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">？</td>
<td align="left">？</td>
</tr>
</tbody></table>
<p>对于 boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素</p>
<p>感兴趣的小伙伴，可以去看官网</p>
<h2 id="Comparator-与-Comparable-有什么区别？"><a href="#Comparator-与-Comparable-有什么区别？" class="headerlink" title="Comparator 与 Comparable 有什么区别？"></a>Comparator 与 Comparable 有什么区别？</h2><p>在牛客网看到这道题的答案，觉得写的最好～</p>
<blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/99f7d1f4f8374e419a6d6924d35d9530">https://www.nowcoder.com/questionTerminal/99f7d1f4f8374e419a6d6924d35d9530</a> 来源：牛客网</p>
<ul>
<li>Comparable &amp; Comparator 都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序，所以，如想实现排序，就需要在集合外定义 Comparator 接口的方法或在集合内实现 Comparable 接口的方法。</li>
<li>Comparator 位于包 java.util 下，而 Comparable 位于包 java.lang 下。</li>
<li>Comparable 是一个对象本身就已经支持自比较所需要实现的接口（如 String、Integer 自己就可以完成比较大小操作，已经实现了 Comparable 接口） 自定义的类要在加入 list 容器中后能够排序，可以实现 Comparable 接口，在用 Collections 类的 sort 方法排序时，如果不指定 Comparator，那么就以自然顺序排序， 这里的自然顺序就是实现 Comparable 接口设定的排序方式。</li>
<li>而 Comparator 是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。</li>
<li>可以说一个是自已完成比较，一个是外部程序实现比较的差别而已。用 Comparator 是策略模式（strategy design pattern），就是不改变对象自身，而用一个策略对象（strategy object）来改变它的行为。比如：你想对整数采用绝对值大小来排序，Integer 是不符合要求的，你不需要去修改 Integer 类（实际上你也不能这么做）去改变它的排序行为，只要使用一个实现了 Comparator 接口的对象来实现控制它的排序就行了。</li>
</ul>
</blockquote>
<h2 id="String-类能被继承吗，为什么。"><a href="#String-类能被继承吗，为什么。" class="headerlink" title="String 类能被继承吗，为什么。"></a>String 类能被继承吗，为什么。</h2><p>首先，String 是一个 final 修饰的类，final 修饰的类不可以被继承。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br></pre></td></tr></table></figure>

<p><strong>String 类为什么不能被继承呢？</strong></p>
<p>有两个原因：</p>
<ul>
<li>效率性，String 类作为最常用的类之一，禁止被继承和重写，可以提高效率。</li>
<li>安全性，String 类中有很多调用底层的本地方法，调用了操作系统的 API，如果方法可以重写，可能被植入恶意代码，破坏程序。</li>
</ul>
<h2 id="说说-Java-中多态的实现原理"><a href="#说说-Java-中多态的实现原理" class="headerlink" title="说说 Java 中多态的实现原理"></a>说说 Java 中多态的实现原理</h2><ul>
<li>多态机制包括静态多态（编译时多态）和动态多态（运行时多态）</li>
<li>静态多态比如说重载，动态多态一般指在运行时才能确定调用哪个方法。</li>
<li>我们通常所说的多态一般指运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直等到运行时才能确定。</li>
<li>多态实现方式：子类继承父类（extends）和类实现接口（implements）</li>
<li>多态核心之处就在于对父类方法的改写或对接口方法的实现，以取得在运行时不同的执行效果。</li>
<li>Java 里对象方法的调用是依靠类信息里的方法表实现的，对象方法引用调用和接口方法引用调用的大致思想是一样的。当调用对象的某个方法时，JVM 查找该对象类的方法表以确定该方法的直接引用地址，有了地址后才真正调用该方法。</li>
</ul>
<p>举个例子吧，假设有个 Fruit 父类，一个 taste 味道方法，两个子类 Apple 和 Pear，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract class Fruit &#123;    abstract String taste() ;&#125;</span><br><span class="line">class Apple extends Fruit &#123;    @Override    String taste() &#123;        return &quot;酸酸的&quot;;    &#125;&#125;</span><br><span class="line">class Pear extends Fruit &#123;    @Override    String taste() &#123;        return &quot;甜甜的&quot;;    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        Fruit f = new Apple();        System.out.println(f.taste());    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行，当调用对象 Fruit f 的方法 taste 时，JVM 查找 Fruit 对象类的方法表以确定 taste 方法的直接引用地址，到底来自 Apple 还是 Pear，确定后才真正调用对应子类的 taste 方法，</p>
<h2 id="Java-泛型和类型擦除"><a href="#Java-泛型和类型擦除" class="headerlink" title="Java 泛型和类型擦除"></a>Java 泛型和类型擦除</h2><p>这个面试题，可以看我这篇文章哈～</p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&mid=2247483865&idx=1&sn=5b0b5f2d669f5d5ebb2c07789e01fcf6&chksm=977945f6a00ecce050167608fc85e3d53b7eb998a41e9d438044ec23e649e732642ea8585416&scene=21#wechat_redirect">Java 程序员必备基础：泛型解析</a></p>
<h2 id="int-和-Integer-有什么区别，还有-Integer-缓存的实现"><a href="#int-和-Integer-有什么区别，还有-Integer-缓存的实现" class="headerlink" title="int 和 Integer 有什么区别，还有 Integer 缓存的实现"></a>int 和 Integer 有什么区别，还有 Integer 缓存的实现</h2><p>这里考察 3 个知识点吧：</p>
<ul>
<li>int 是基本数据类型，interger 是 int 的封装类</li>
<li>int 默认值为 0 ，而 interger 默认值为 null， Interger 使用需要判空处理</li>
<li>Integer 的缓存机制：为了节省内存和提高性能，Integer 类在内部通过使用相同的对象引用实现缓存和重用，Integer 类默认在 - 128 ~ 127 之间，可以通过 -XX:AutoBoxCacheMax 进行修改，且这种机制仅在自动装箱的时候有用，在使用构造器创建 Integer 对象时无用。</li>
</ul>
<p>看个 Integer 的缓存的例子，加深一下印象哈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 10;Integer b = 10;</span><br><span class="line">Integer c = 129;Integer d = 129;System.out.println(a == b);System.out.println(c == d);输出结果：truefalse</span><br></pre></td></tr></table></figure>

<h2 id="说说反射的用途及实现原理，Java-获取反射的三种方法"><a href="#说说反射的用途及实现原理，Java-获取反射的三种方法" class="headerlink" title="说说反射的用途及实现原理，Java 获取反射的三种方法"></a>说说反射的用途及实现原理，Java 获取反射的三种方法</h2><p>这道面试题，看我这篇文章哈：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&mid=2247483838&idx=1&sn=09555821d0d32d258627404dceb21dfb&chksm=97794591a00ecc87a5e921fd4e00dd5e8b501aebb05174d69c93d8ae1dd3cb9c31926e11737e&scene=21#wechat_redirect">谈谈 Java 反射：从入门到实践，再到原理</a></p>
<p>Java 获取反射的<strong>三种方法</strong>：</p>
<ul>
<li>第一种，使用 Class.forName 静态方法。</li>
<li>第二种，使用类的.class 方法</li>
<li>第三种，使用实例对象的 getClass () 方法。</li>
</ul>
<h2 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h2><p>面向对象的三大特征：</p>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="&amp; 和 &amp;&amp; 的区别"></a>&amp; 和 &amp;&amp; 的区别</h2><ul>
<li>按位与，a&amp;b 表示把 a 和 b 都转换成二进制数，再进行与的运算；</li>
<li>&amp; 和 &amp;&amp; 都是逻辑运算符号，&amp;&amp; 又叫短路运算符</li>
<li>逻辑与，a&amp;&amp; b ，a&amp;b 都表示当且仅当两个操作数均为 true 时，其结果才为 true，否则为 false。</li>
<li>逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true，整个表达式的值才是 true。但是，&amp;&amp; 之所以称为短路运算，是因为如果 &amp;&amp; 左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</li>
</ul>
<h2 id="Java-中-IO-流分为几种？"><a href="#Java-中-IO-流分为几种？" class="headerlink" title="Java 中 IO 流分为几种？"></a>Java 中 IO 流分为几种？</h2><ul>
<li>Java 中的流分为两种：一种是字节流，另一种是字符流。</li>
<li>IO 流分别由四个抽象类来表示（两输入两输出）:InputStream，OutputStream，Reader，Writer。</li>
</ul>
<h2 id="讲讲类的实例化顺序，比如父类静态数据，构造函数，子类静态数据，构造函数"><a href="#讲讲类的实例化顺序，比如父类静态数据，构造函数，子类静态数据，构造函数" class="headerlink" title="讲讲类的实例化顺序，比如父类静态数据，构造函数，子类静态数据，构造函数"></a>讲讲类的实例化顺序，比如父类静态数据，构造函数，子类静态数据，构造函数</h2><p>直接看个例子吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Parent &#123;    &#123;        System.out.println(&quot;父类非静态代码块&quot;);    &#125;    static &#123;        System.out.println(&quot;父类静态块&quot;);    &#125;    public Parent() &#123;        System.out.println(&quot;父类构造器&quot;);    &#125;&#125;public class Son extends Parent &#123;    public Son() &#123;        System.out.println(&quot;子类构造器&quot;);    &#125;    static &#123;        System.out.println(&quot;子类静态代码块&quot;);    &#125;    &#123;        System.out.println(&quot;子类非静态代码块&quot;);    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        Son son = new Son();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类静态块子类静态代码块父类非静态代码块父类构造器子类非静态代码块子类构造器</span><br></pre></td></tr></table></figure>

<p>所以，<strong>类实例化顺序为：</strong>父类静态代码块 &#x2F; 静态域 -&gt; 子类静态代码块 &#x2F; 静态域 -&gt; 父类非静态代码块 -&gt; 父类构造器 -&gt; 子类非静态代码块 -&gt; 子类构造器</p>
<h2 id="Java-创建对象有几种方式"><a href="#Java-创建对象有几种方式" class="headerlink" title="Java 创建对象有几种方式"></a>Java 创建对象有几种方式</h2><p>Java 创建对象有 5 种方式</p>
<ul>
<li>用 new 语句创建对象</li>
<li>使用反射，使用 Class.newInstance () 创建对象 &#x2F; 调用类对象的构造方法 ——Constructor</li>
<li>调用对象的 clone () 方法</li>
<li>运用反序列化手段，调用 java.io.ObjectInputStream 对象的 readObject () 方法</li>
<li>使用 Unsafe</li>
</ul>
<h2 id="如何将-GB2312-编码的字符串转换为-ISO-8859-1-编码的字符串呢？"><a href="#如何将-GB2312-编码的字符串转换为-ISO-8859-1-编码的字符串呢？" class="headerlink" title="如何将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串呢？"></a>如何将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串呢？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;        </span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;捡田螺的小男孩&quot;</span>;        </span><br><span class="line">    <span class="type">String</span> <span class="variable">strIso</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(str.getBytes(<span class="string">&quot;GB2312&quot;</span>), <span class="string">&quot;ISO-8859-1&quot;</span>);        </span><br><span class="line">    System.out.println(strIso);    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="守护线程是什么？用什么方法实现守护线程"><a href="#守护线程是什么？用什么方法实现守护线程" class="headerlink" title="守护线程是什么？用什么方法实现守护线程"></a>守护线程是什么？用什么方法实现守护线程</h2><ul>
<li>守护线程是运行在后台的一种特殊进程。</li>
<li>它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。</li>
<li>在 Java 中垃圾回收线程就是特殊的守护线程。</li>
</ul>
<h2 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify () 和 notifyAll () 有什么区别？"></a>notify () 和 notifyAll () 有什么区别？</h2><ul>
<li>notify 是唤醒一个处于该对象 wait 的线程，而 notifyAll 是唤醒所有处于该对象 wait 的线程。</li>
<li>但是唤醒不等于就能执行了，需要得到锁对象才能有权利继续执行，而锁只有一把，所以多个线程被唤醒时需要争取该锁。</li>
</ul>
<h2 id="Java-语言是如何处理异常的，关键字-throws、throw、try、catch、finally-怎么使用？"><a href="#Java-语言是如何处理异常的，关键字-throws、throw、try、catch、finally-怎么使用？" class="headerlink" title="Java 语言是如何处理异常的，关键字 throws、throw、try、catch、finally 怎么使用？"></a>Java 语言是如何处理异常的，关键字 throws、throw、try、catch、finally 怎么使用？</h2><p>这道面试题，可以看我这篇文章哈：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&mid=2247483820&idx=1&sn=312fef59c2e24b213213f78ec697dc4a&chksm=97794583a00ecc95deeda60a5229047d7e39c77d4da89be76ce5e8e72afcfda6efb7287ccaf4&scene=21#wechat_redirect">Java 程序员必备：异常的十个关键知识点</a></p>
<h2 id="谈谈-Java-的异常层次结构"><a href="#谈谈-Java-的异常层次结构" class="headerlink" title="谈谈 Java 的异常层次结构"></a>谈谈 Java 的异常层次结构</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>从前从前，有位老人，他的名字叫 <strong>Throwable</strong>，他生了两个儿子，大儿子叫 <strong>Error</strong>, 二儿子叫 <strong>Exception</strong>。</p>
<p><strong>Error</strong></p>
<p>表示编译时或者系统错误，如虚拟机相关的错误，OutOfMemoryError 等，error 是无法处理的。</p>
<p><strong>Exception</strong></p>
<p>代码异常，Java 程序员关心的基类型通常是 Exception。它能被程序本身可以处理，这也是它跟 Error 的区别。</p>
<p>它可以分为 RuntimeException（运行时异常）和 CheckedException（可检查的异常）。</p>
<p><strong>常见的 RuntimeException 异常：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- NullPointerException 空指针异常- ArithmeticException 出现异常的运算条件时，抛出此异常- IndexOutOfBoundsException 数组索引越界异常- ClassNotFoundException 找不到类异常- IllegalArgumentException(非法参数异常)</span><br></pre></td></tr></table></figure>

<p><strong>常见的 Checked Exception 异常：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- IOException (操作输入流和输出流时可能出现的异常)- ClassCastException(类型转换异常类)</span><br></pre></td></tr></table></figure>

<ul>
<li>Checked Exception 就是编译器要求你必须处置的异常。</li>
<li>与之相反的是，Unchecked Exceptions，它指编译器不要求强制处置的异常，它包括 Error 和 RuntimeException 以及他们的子类。</li>
</ul>
<h2 id="静态内部类与非静态内部类有什么区别"><a href="#静态内部类与非静态内部类有什么区别" class="headerlink" title="静态内部类与非静态内部类有什么区别"></a>静态内部类与非静态内部类有什么区别</h2><p>这道面试题，可以看我这篇文章哈：Java 程序员必备基础：内部类解析</p>
<ul>
<li>静态内部类可以有静态成员 (方法，属性)，而非静态内部类则不能有静态成员 (方法，属性)。</li>
<li>静态内部类只能够访问外部类的静态成员和静态方法，而非静态内部类则可以访问外部类的所有成员 (方法，属性)。</li>
<li>实例化静态内部类与非静态内部类的方式不同</li>
<li>调用内部静态类的方法或静态变量，可以通过类名直接调用</li>
</ul>
<h2 id="String-s-与-new-String-与有什么区别"><a href="#String-s-与-new-String-与有什么区别" class="headerlink" title="String s 与 new String 与有什么区别"></a>String s 与 new String 与有什么区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str =&quot;whx&quot;;String newStr =new String (&quot;whx&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>String str &#x3D;”whx”</strong></p>
<p>先在常量池中查找有没有 “whx” 这个对象，如果有，就让 str 指向那个 “whx”. 如果没有，在常量池中新建一个 “whx” 对象，并让 str 指向在常量池中新建的对象 “whx”。</p>
<p><strong>String newStr &#x3D;new String (“whx”);</strong></p>
<p>是在堆中建立的对象 “whx” , 在栈中创建堆中 “whx” 对象的内存地址。</p>
<p>如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzFqTyibxYauPWFYQ6d1hDR8XxxluP7Pn1McN2TSukH0LTVNaVTTIx2wZece8n0DMQgEVXGUiaAsZdPA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>网上这篇文章讲的挺好的：String 和 New String () 的区别</p>
<h2 id="反射中，Class-forName-和-ClassLoader-的区别"><a href="#反射中，Class-forName-和-ClassLoader-的区别" class="headerlink" title="反射中，Class.forName 和 ClassLoader 的区别"></a>反射中，Class.forName 和 ClassLoader 的区别</h2><p>Class.forName 和 ClassLoader 都可以对类进行加载。它们区别在哪里呢？<strong>ClassLoader</strong> 负责加载 Java 类的字节代码到 Java 虚拟机中。Class.forName 其实是调用了 ClassLoader，如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">这里面，forName0 的第二个参数为 true，表示对加载的类进行初始化化。其实还可以调用 <code>Class&lt;?&gt;forName(Stringname,booleaninitialize,ClassLoaderloader)</code>方法实现一样的功能，它的源码如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzFqTyibxYauPWFYQ6d1hDR8XiavnyjksQxzWYsdwnwAIc3ibfkYK9AQ124sH0iba20KoQNdGHbDAs5qHA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>所以，Class.forName 和 ClassLoader 的区别，就是在类加载的时候，class.forName 有参数控制是否对类进行初始化。</p>
<h2 id="JDK-动态代理与-cglib-实现的区别"><a href="#JDK-动态代理与-cglib-实现的区别" class="headerlink" title="JDK 动态代理与 cglib 实现的区别"></a>JDK 动态代理与 cglib 实现的区别</h2><ul>
<li>java 动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用 InvokeHandler 来处理。</li>
<li>cglib 动态代理是利用 asm 开源包，对代理对象类的 class 文件加载进来，通过修改其字节码生成子类来处理。</li>
<li>JDK 动态代理只能对实现了接口的类生成代理，而不能针对类</li>
<li>cglib 是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。因为是继承，所以该类或方法最好不要声明成 final</li>
</ul>
<h2 id="error-和-exception-的区别，CheckedException，RuntimeException-的区别。"><a href="#error-和-exception-的区别，CheckedException，RuntimeException-的区别。" class="headerlink" title="error 和 exception 的区别，CheckedException，RuntimeException 的区别。"></a>error 和 exception 的区别，CheckedException，RuntimeException 的区别。</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzFqTyibxYauPWFYQ6d1hDR8Xjoqf0qb9fcoJWhaPVZps8Jnic9RZ6cqe3ibwtn2TKk1AjgSqof6bblAg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Error:</strong> 表示编译时或者系统错误，如虚拟机相关的错误，OutOfMemoryError 等，error 是无法处理的。</p>
<p><strong>Exception:</strong> 代码异常，Java 程序员关心的基类型通常是 Exception。它能被程序本身可以处理，这也是它跟 Error 的区别。</p>
<p>它可以分为 RuntimeException（运行时异常）和 CheckedException（可检查的异常）。常见的 RuntimeException 异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- NullPointerException 空指针异常- ArithmeticException 出现异常的运算条件时，抛出此异常- IndexOutOfBoundsException 数组索引越界异常- ClassNotFoundException 找不到类异常- IllegalArgumentException(非法参数异常)</span><br></pre></td></tr></table></figure>

<p>常见的 Checked Exception 异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- IOException (操作输入流和输出流时可能出现的异常)- ClassCastException(类型转换异常类)</span><br></pre></td></tr></table></figure>

<p>有兴趣可以看我之前写得这篇文章：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&mid=2247483820&idx=1&sn=312fef59c2e24b213213f78ec697dc4a&chksm=97794583a00ecc95deeda60a5229047d7e39c77d4da89be76ce5e8e72afcfda6efb7287ccaf4&scene=21#wechat_redirect">Java 程序员必备：异常的十个关键知识点</a></p>
<h2 id="深拷贝和浅拷贝区别"><a href="#深拷贝和浅拷贝区别" class="headerlink" title="深拷贝和浅拷贝区别"></a>深拷贝和浅拷贝区别</h2><p><strong>浅拷贝</strong></p>
<p>复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzFqTyibxYauPWFYQ6d1hDR8Xu7jr3eUWa6aBpzPgr1toIFaniaJddAGhxL4xWXibOSicL9HicLTMQUDMGQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>深拷贝</strong></p>
<p>将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzFqTyibxYauPWFYQ6d1hDR8XLf4AjnXZpfCrcHOJm5rHia0mJqNMAjGicDia6aobQldJ6Jic0UiacyDJ58Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="JDK-和-JRE-有什么区别？"><a href="#JDK-和-JRE-有什么区别？" class="headerlink" title="JDK 和 JRE 有什么区别？"></a>JDK 和 JRE 有什么区别？</h2><ul>
<li>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</li>
<li>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。</li>
</ul>
<h2 id="String-类的常用方法都有那些呢？"><a href="#String-类的常用方法都有那些呢？" class="headerlink" title="String 类的常用方法都有那些呢？"></a>String 类的常用方法都有那些呢？</h2><ul>
<li>indexOf ()：返回指定字符的索引。</li>
<li>charAt ()：返回指定索引处的字符。</li>
<li>replace ()：字符串替换。</li>
<li>trim ()：去除字符串两端空白。</li>
<li>split ()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes ()：返回字符串的 byte 类型数组。</li>
<li>length ()：返回字符串长度。</li>
<li>toLowerCase ()：将字符串转成小写字母。</li>
<li>toUpperCase ()：将字符串转成大写字符。</li>
<li>substring ()：截取字符串。</li>
<li>equals ()：字符串比较。</li>
</ul>
<h2 id="谈谈自定义注解的场景及实现"><a href="#谈谈自定义注解的场景及实现" class="headerlink" title="谈谈自定义注解的场景及实现"></a>谈谈自定义注解的场景及实现</h2><ul>
<li>之前我这边有这么一个业务场景，用 Redis 控制接口调用频率，有使用过自定义注解</li>
<li>通过 AOP（动态代理机制）给方法添加切面，通过反射来获取方法包含的注解，如果包含自定义关键字注解，就通过 Redis 进行校验拦截请求</li>
</ul>
<p>有关于注解，建议大家看一下 java 编程思想的注解篇章哈～</p>
<h2 id="说说你熟悉的设计模式有哪些？"><a href="#说说你熟悉的设计模式有哪些？" class="headerlink" title="说说你熟悉的设计模式有哪些？"></a>说说你熟悉的设计模式有哪些？</h2><p>设计模式分为三大类：</p>
<ul>
<li>创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式（5 种）</li>
<li>结构型模式：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式。（7 种）</li>
<li>行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。（11 种）</li>
</ul>
<p>最好平时积累一下，单例模式（7 种实现方式），工厂模式，模板方法设计模式，策略模式，装饰者模式、代理模式这几种怎么写吧～</p>
<h2 id="抽象工厂和工厂方法模式的区别？"><a href="#抽象工厂和工厂方法模式的区别？" class="headerlink" title="抽象工厂和工厂方法模式的区别？"></a>抽象工厂和工厂方法模式的区别？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">可以看一下这篇文章介绍：抽象工厂模式 - 与 - 工厂方法模式区别</p>
<h2 id="什么是值传递和引用传递？"><a href="#什么是值传递和引用传递？" class="headerlink" title="什么是值传递和引用传递？"></a>什么是值传递和引用传递？</h2><ul>
<li>值传递是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量.</li>
<li>引用传递一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身 。所以对引用对象进行操作会同时改变原对象.</li>
</ul>
<h2 id="可以在-static-环境中访问非-static-变量吗？"><a href="#可以在-static-环境中访问非-static-变量吗？" class="headerlink" title="可以在 static 环境中访问非 static 变量吗？"></a>可以在 static 环境中访问非 static 变量吗？</h2><blockquote>
<p>static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 static 变量进行初始化。因为静态的成员属于类，随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员。类的加载先于实例的创建，因此静态环境中，不可以访问非静态！</p>
</blockquote>
<h2 id="Java-支持多继承么，为什么？"><a href="#Java-支持多继承么，为什么？" class="headerlink" title="Java 支持多继承么，为什么？"></a>Java 支持多继承么，为什么？</h2><p>不支持多继承，原因:</p>
<ul>
<li>安全性的考虑，如果子类继承的多个父类里面有相同的方法或者属性，子类将不知道具体要继承哪个</li>
<li>Java 提供了接口和内部类以达到实现多继承功能，弥补单继承的缺陷。</li>
</ul>
<h2 id="用最有效率的方法计算-2-乘以-8？"><a href="#用最有效率的方法计算-2-乘以-8？" class="headerlink" title="用最有效率的方法计算 2 乘以 8？"></a>用最有效率的方法计算 2 乘以 8？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;&lt; 3</span><br></pre></td></tr></table></figure>

<ul>
<li>将一个数左移 n 位，就相当于这个数乘以了 2 的 n 次方。</li>
<li>那么，一个数乘以 8 只要将其左移 3 位即可。</li>
<li>而 cpu 直接支持位移运算，且效率最高。</li>
</ul>
<h2 id="构造器是否可被重写？"><a href="#构造器是否可被重写？" class="headerlink" title="构造器是否可被重写？"></a>构造器是否可被重写？</h2><p>构造器是不能被继承的，因为每个类的类名都不相同，而构造器名称与类名相同，所以谈不上继承。又由于构造器不能被继承，所以相应的就不能被重写了。</p>
<h2 id="char-型变量中能不能存贮一个中文汉字，为什么？"><a href="#char-型变量中能不能存贮一个中文汉字，为什么？" class="headerlink" title="char 型变量中能不能存贮一个中文汉字，为什么？"></a>char 型变量中能不能存贮一个中文汉字，为什么？</h2><p>在 Java 中，char 类型占 2 个字节，而且 Java 默认采用 Unicode 编码，一个 Unicode 码是 16 位，所以一个 Unicode 码占两个字节，Java 中无论汉子还是英文字母都是用 Unicode 编码来表示的。<strong>所以，在 Java 中，char 类型变量可以存储一个中文汉字</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char ch = &#x27;啦&#x27;;System.out.println(&quot;char:&quot; + ch);</span><br></pre></td></tr></table></figure>

<h2 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h2><ul>
<li>实现 Cloneable 接口，重写 clone () 方法。</li>
<li>Object 的 clone () 方法是浅拷贝，即如果类中属性有自定义引用类型，只拷贝引用，不拷贝引用指向的对象。</li>
<li>对象的属性的 Class 也实现 Cloneable 接口，在克隆对象时也手动克隆属性，完成深拷贝</li>
<li>结合序列化 (JDK java.io.Serializable 接口、JSON 格式、XML 格式等)，完成深拷贝</li>
</ul>
<h2 id="object-中定义了哪些方法？"><a href="#object-中定义了哪些方法？" class="headerlink" title="object 中定义了哪些方法？"></a>object 中定义了哪些方法？</h2><ul>
<li>getClass (); 获取类结构信息</li>
<li>hashCode () 获取哈希码</li>
<li>equals (Object) 默认比较对象的地址值是否相等，子类可以重写比较规则</li>
<li>clone () 用于对象克隆</li>
<li>toString () 把对象转变成字符串</li>
<li>notify () 多线程中唤醒功能</li>
<li>notifyAll () 多线程中唤醒所有等待线程的功能</li>
<li>wait () 让持有对象锁的线程进入等待</li>
<li>wait (long timeout) 让持有对象锁的线程进入等待，设置超时毫秒数时间</li>
<li>wait (long timeout, int nanos) 让持有对象锁的线程进入等待，设置超时纳秒数时间</li>
<li>finalize () 垃圾回收前执行的方法</li>
</ul>
<h2 id="hashCode-的作用是什么？"><a href="#hashCode-的作用是什么？" class="headerlink" title="hashCode 的作用是什么？"></a>hashCode 的作用是什么？</h2><blockquote>
<ul>
<li>hashCode 的存在主要是用于查找的快捷性，如 Hashtable，HashMap 等，hashCode 是用来在散列存储结构中确定对象的存储地址的；</li>
<li>如果两个对象相同，就是适用于 equals (java.lang.Object) 方法，那么这两个对象的 hashCode 一定要相同；</li>
<li>如果对象的 equals 方法被重写，那么对象的 hashCode 也尽量重写，并且产生 hashCode 使用的对象，一定要和 equals 方法中使用的一致，否则就会违反上面提到的第 2 点；</li>
<li>两个对象的 hashCode 相同，并不一定表示两个对象就相同，也就是不一定适用于 equals (java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中.</li>
</ul>
</blockquote>
<h2 id="for-each-与常规-for-循环的效率对比"><a href="#for-each-与常规-for-循环的效率对比" class="headerlink" title="for-each 与常规 for 循环的效率对比"></a>for-each 与常规 for 循环的效率对比</h2><p>关于这个问题，《Effective Java》给我们做的解答：</p>
<blockquote>
<p>for-each 能够让代码更加清晰，并且减少了出错的机会。下面的惯用代码适用于集合与数组类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (Element e : elements) &#123;     doSomething(e); &#125;</span><br></pre></td></tr></table></figure>

<p>使用 for-each 循环与常规的 for 循环相比，并不存在性能损失，即使对数组进行迭代也是如此。实际上，在有些场合下它还能带来微小的性能提升，因为它只计算一次数组索引的上限。</p>
</blockquote>
<h2 id="写出几种单例模式实现，懒汉模式和饿汉模式区别"><a href="#写出几种单例模式实现，懒汉模式和饿汉模式区别" class="headerlink" title="写出几种单例模式实现，懒汉模式和饿汉模式区别"></a>写出几种单例模式实现，懒汉模式和饿汉模式区别</h2><p>7 种：</p>
<ul>
<li>第一种（懒汉，线程不安全）</li>
<li>第二种（懒汉，线程安全）</li>
<li>第三种（饿汉）</li>
<li>第四种（饿汉，变种）</li>
<li>第五种（静态内部类）</li>
<li>第六种（枚举）：</li>
<li>第七种（双重校验锁）</li>
</ul>
<p>可以看这篇文章：单例模式的七种写法</p>
<h2 id="请列出-5-个运行时异常"><a href="#请列出-5-个运行时异常" class="headerlink" title="请列出 5 个运行时异常"></a>请列出 5 个运行时异常</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- NullPointerException 空指针异常- ArithmeticException 出现异常的运算条件时，抛出此异常- IndexOutOfBoundsException 数组索引越界异常- ClassNotFoundException 找不到类异常- IllegalArgumentException(非法参数异常)</span><br></pre></td></tr></table></figure>

<h2 id="2-个不相等的对象有可能具有相同的-hashcode-吗？"><a href="#2-个不相等的对象有可能具有相同的-hashcode-吗？" class="headerlink" title="2 个不相等的对象有可能具有相同的 hashcode 吗？"></a>2 个不相等的对象有可能具有相同的 hashcode 吗？</h2><p>有可能哈～</p>
<p><strong>hashCode 的常规协定：</strong></p>
<ul>
<li>在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致</li>
<li>两个对象的 equals () 相等，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果</li>
<li>两个对象的 equals () 不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不要求一定生成不同的整数结果。但是，为不相等的对象生成不同整数结果可以提高哈希表的性能</li>
</ul>
<h2 id="访问修饰符-public-private-protected-以及-default-的区别？"><a href="#访问修饰符-public-private-protected-以及-default-的区别？" class="headerlink" title="访问修饰符 public,private,protected, 以及 default 的区别？"></a>访问修饰符 public,private,protected, 以及 default 的区别？</h2><p>保护子类，默认同包</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzFqTyibxYauPWFYQ6d1hDR8XFUK78CpyTmYmZ28nib31xfLb1ZkpVAcmRtAPibic97KMd0iclHyELEOslw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="谈谈-final-在-java-中的作用？"><a href="#谈谈-final-在-java-中的作用？" class="headerlink" title="谈谈 final 在 java 中的作用？"></a>谈谈 final 在 java 中的作用？</h2><ul>
<li>final 修饰的类叫最终类，该类不能被继承</li>
<li>final 修饰的方法不能被重写</li>
<li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改</li>
</ul>
<h2 id="java-中的-Math-round-1-5-等于多少呢？"><a href="#java-中的-Math-round-1-5-等于多少呢？" class="headerlink" title="java 中的 Math.round (-1.5) 等于多少呢？"></a>java 中的 Math.round (-1.5) 等于多少呢？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzFqTyibxYauPWFYQ6d1hDR8Xr4uic5m8YzVHx7VTlbrz5R9XpicxqKa8c458TFU2ZdvdjxwT8OHAItlw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>JDK 中的 java.lang.Math 类:</p>
<ul>
<li>round () ：返回四舍五入，负 .5 小数返回较大整数，如 -1.5 返回 -1。</li>
<li>ceil () ：返回小数所在两整数间的较大值，如 -1.5 返回 -1.0。</li>
<li>floor () ：返回小数所在两整数间的较小值，如 -1.5 返回 -2.0。</li>
</ul>
<h2 id="String-属于基础的数据类型吗？"><a href="#String-属于基础的数据类型吗？" class="headerlink" title="String 属于基础的数据类型吗？"></a>String 属于基础的数据类型吗？</h2><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p>
<h2 id="如何将字符串反转呢？"><a href="#如何将字符串反转呢？" class="headerlink" title="如何将字符串反转呢？"></a>如何将字符串反转呢？</h2><ul>
<li>使用 StringBuilder 或 StringBuffer 的 reverse 方法，本质都调用了它们的父类 AbstractStringBuilder 的 reverse 方法实现。（JDK1.8）</li>
<li>使用 chatAt 函数，倒过来输出；</li>
</ul>
<h2 id="描述动态代理的几种实现方式，它们分别有什么优缺点"><a href="#描述动态代理的几种实现方式，它们分别有什么优缺点" class="headerlink" title="描述动态代理的几种实现方式，它们分别有什么优缺点"></a>描述动态代理的几种实现方式，它们分别有什么优缺点</h2><ul>
<li>JDK 动态代理</li>
<li>CGLIB 动态代理</li>
<li>JDK 原声动态代理时 java 原声支持的、不需要任何外部依赖、但是它只能基于接口进行代理</li>
<li>CGLIB 通过继承的方式进行代理、无论目标对象没有没实现接口都可以代理，但是无法处理 final 的情况</li>
</ul>
<h2 id="在自己的代码中，如果创建一个-java-lang-String-类，这个类是否可以被类加载器加载？为什么"><a href="#在自己的代码中，如果创建一个-java-lang-String-类，这个类是否可以被类加载器加载？为什么" class="headerlink" title="在自己的代码中，如果创建一个 java.lang.String 类，这个类是否可以被类加载器加载？为什么"></a>在自己的代码中，如果创建一个 java.lang.String 类，这个类是否可以被类加载器加载？为什么</h2><p>不可以。因为 JDK 处于安全性的考虑，基于双亲委派模型，优先加载 JDK 的 String 类，如果 java.lang.String 已经加载，便不会再次被加载。</p>
<h2 id="谈谈你对-java-lang-Object-对象中-hashCode-和-equals-方法的理解。在什么场景下需要重新实现这两个方法"><a href="#谈谈你对-java-lang-Object-对象中-hashCode-和-equals-方法的理解。在什么场景下需要重新实现这两个方法" class="headerlink" title="谈谈你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需要重新实现这两个方法"></a>谈谈你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需要重新实现这两个方法</h2><blockquote>
<ul>
<li>在我们的业务系统中判断对象时有时候需要的不是一种严格意义上的相等，而是一种业务上的对象相等。在这种情况下，原生的 equals 方法就不能满足我们的需求了，所以这个时候我们需要重写 equals 方法，来满足我们的业务系统上的需求。</li>
<li>那么为什么在重写 equals 方法的时候需要重写 hashCode 方法呢？如果只重写了 equals 方法而没有重写 hashCode 方法的话，则会违反约定的第二条：相等的对象必须具有相等的散列码。所以 hashCode 和 equals 方法都需要重写</li>
</ul>
</blockquote>
<h2 id="在-jdk1-5-中，引入了泛型，泛型的存在是用来解决什么问题"><a href="#在-jdk1-5-中，引入了泛型，泛型的存在是用来解决什么问题" class="headerlink" title="在 jdk1.5 中，引入了泛型，泛型的存在是用来解决什么问题"></a>在 jdk1.5 中，引入了泛型，泛型的存在是用来解决什么问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java 泛型（generics）是 JDK 5 中引入的一个新特性，其本质是参数化类型，解决不确定具体对象类型的问题。</span><br></pre></td></tr></table></figure>

<p>这个面试题，可以看我这篇文章哈～Java 程序员必备基础：泛型解析</p>
<h2 id="什么是序列化，怎么序列化，反序列呢？"><a href="#什么是序列化，怎么序列化，反序列呢？" class="headerlink" title="什么是序列化，怎么序列化，反序列呢？"></a>什么是序列化，怎么序列化，反序列呢？</h2><ul>
<li>序列化：把 Java 对象转换为字节序列的过程</li>
<li>反序列：把字节序列恢复为 Java 对象的过程 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzFqTyibxYauPWFYQ6d1hDR8X4JQTRjSicJUTxxRMJBbTL26DibuNTrk3SapH8D0emMDF44QNpibJd3S5g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li>
</ul>
<p>可以看我这篇文章哈～<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&mid=2247484021&idx=1&sn=d7760254bd36f3a39dc8705ad40b469f&chksm=9779465aa00ecf4cfb5513a0ac41a31f318df2565b3e4ac739e62abfedad21d5a1e483f63f63&scene=21#wechat_redirect">Java 程序员必备：序列化全方位解析</a></p>
<h2 id="java8-的新特性"><a href="#java8-的新特性" class="headerlink" title="java8 的新特性"></a>java8 的新特性</h2><ul>
<li><p>Lambda 表达式：Lambda 允许把函数作为一个方法的参数</p>
</li>
<li><p>Stream API ：新添加的 Stream API（java.util.stream） 把真正的函数式编程风格引入到 Java 中</p>
</li>
<li><p>方法引用：方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象（实例）的方法或构造器</p>
</li>
<li><p>默认方法：默认方法就是一个在接口里面有了一个实现的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;T&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Optional 类 ：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常</p>
</li>
<li><p>Date Time API ：加强对日期与时间的处理</p>
</li>
</ul>
<h2 id="匿名内部类是什么？如何访问在其外面定义的变量呢？"><a href="#匿名内部类是什么？如何访问在其外面定义的变量呢？" class="headerlink" title="匿名内部类是什么？如何访问在其外面定义的变量呢？"></a>匿名内部类是什么？如何访问在其外面定义的变量呢？</h2><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123;        </span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Service</span>() &#123;            </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;                </span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;                    </span><br><span class="line">            System.out.println(<span class="string">&quot;匿名内部类&quot;</span> );                </span><br><span class="line">          &#125;            </span><br><span class="line">        &#125;        </span><br><span class="line">      &#125;.method();    </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="comment">//匿名内部类必须继承或实现一个已有的接口 interface Service&#123;    void method();&#125;</span></span><br></pre></td></tr></table></figure>

<p>匿名内部类还有以下特点：</p>
<ul>
<li>匿名内部类没有名字的</li>
<li>匿名内部类必须实现一个接口或继承一个抽象类或继承一个普通类</li>
<li>匿名内部类不能定义任何静态成员和静态方法</li>
<li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final</li>
<li><strong>匿名内部类不能是抽象的</strong>，它必须要实现继承的类或者实现的接口的所有抽象方法</li>
<li>匿名内部类不能访问外部类方法中的局部变量，除非该变量被声明为 final 类型</li>
</ul>
<p>可以看我这篇文章哈～<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&mid=2247483860&idx=1&sn=1f605d8eba138c25b663f63ff99656e1&chksm=977945fba00ecced3fbde14fabe5bb5feb33fa875b64483f06082a27356175e0763625b93846&scene=21#wechat_redirect">Java 程序员必备基础：内部类解析</a></p>
<h2 id="break-和-continue-有什么区别？"><a href="#break-和-continue-有什么区别？" class="headerlink" title="break 和 continue 有什么区别？"></a>break 和 continue 有什么区别？</h2><ul>
<li>break 可以使流程跳出 switch 语句体，也可以在循环结构终止本层循环体，从而提前结束本层循环。</li>
<li>continue 的作用是跳过本次循环体中余下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为仅结束本次循环</li>
</ul>
<h2 id="String-s-“Hello”-s-s-“world-”-这两行代码执行后，原始的-String-对象中的内容是否会改变？"><a href="#String-s-“Hello”-s-s-“world-”-这两行代码执行后，原始的-String-对象中的内容是否会改变？" class="headerlink" title="String s &#x3D; “Hello”;s &#x3D; s + “world!”; 这两行代码执行后，原始的 String 对象中的内容是否会改变？"></a>String s &#x3D; “Hello”;s &#x3D; s + “world!”; 这两行代码执行后，原始的 String 对象中的内容是否会改变？</h2><p>没有。因为 String 被设计成不可变 (immutable) 类，所以它的所有对象都是不可变对象。</p>
<h2 id="String-s-“a”-”b”-”c”-”d”-创建了几个对象？"><a href="#String-s-“a”-”b”-”c”-”d”-创建了几个对象？" class="headerlink" title="String s &#x3D; “a”+”b”+”c”+”d”; 创建了几个对象？"></a>String s &#x3D; “a”+”b”+”c”+”d”; 创建了几个对象？</h2><p>1 个而已啦</p>
<blockquote>
<p>Java 编译器对字符串常量直接相加的表达式进行优化，不等到运行期去进行加法运算，在编译时就去掉了加号，直接将其编译成一个这些常量相连的结果。所以 “a”+”b”+”c”+”d” 相当于直接定义一个 “abcd” 的字符串。</p>
</blockquote>
<h2 id="try-catch-finally-return-执行顺序"><a href="#try-catch-finally-return-执行顺序" class="headerlink" title="try-catch-finally-return 执行顺序"></a>try-catch-finally-return 执行顺序</h2><p>try-catch-finally-return 执行描述:</p>
<ul>
<li>如果不发生异常，不会执行 catch 部分</li>
<li>不管有没有发生异常，finally 都会执行到</li>
<li>即使 try 和 catch 中有 return 时，finally 仍然会执行</li>
<li>finally 是在 return 后面的表达式运算完后再执行的。（此时并没有返回运算后的值，而是先把要返回的值保存起来，若 finally 中无 return，则不管 finally 中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），该情况下函数返回值是在 finally 执行前确定的)</li>
<li>finally 部分就不要 return 了，要不然，就回不去 try 或者 catch 的 return 了</li>
</ul>
<p>看一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;        System.out.println(&quot;result：&quot; + test());    &#125;</span><br><span class="line">   private static int test() &#123;        int temp = 1;        try &#123;            System.out.println(&quot;start execute try,temp is:&quot;+temp);            return ++temp;        &#125; catch (Exception e) &#123;            System.out.println(&quot;start execute catch temp is: &quot;+temp);            return ++temp;        &#125; finally &#123;            System.out.println(&quot;start execute finally,temp is:&quot; + temp);            ++temp;        &#125;    &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start execute try,temp is:1start execute finally,temp is:2result:2</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>先执行 try 部分，输出日志，执行 <code>++temp</code>表达式，temp 变为 2, 这个值被保存起来。</li>
<li>因为没有发生异常，所以 catch 代码块跳过。</li>
<li>执行 finally 代码块，输出日志，执行 <code>++temp</code>表达式</li>
<li>返回 try 部分保存的值 2.</li>
</ul>
<h2 id="简述一下面向对象的”-六原则一法则”。"><a href="#简述一下面向对象的”-六原则一法则”。" class="headerlink" title="简述一下面向对象的” 六原则一法则”。"></a>简述一下面向对象的” 六原则一法则”。</h2><ul>
<li>单一职责原则：一个类只做它该做的事情。</li>
<li>开闭原则：软件实体应当对扩展开放，对修改关闭。</li>
<li>依赖倒转原则：面向接口编程。</li>
<li>接口隔离原则：接口要小而专，绝不能大而全。</li>
<li>合成聚合复用原则：优先使用聚合或合成关系复用代码。</li>
<li>迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 开闭原则：对扩展开放，对修改关闭</span><br><span class="line">2. 里氏替换原则：继承必须确保超类所拥有的性质在子类中仍然成立</span><br><span class="line">3. 依赖倒置原则：要面向接口编程,不要面向实现编程</span><br><span class="line">4. 单一职责原则：控制类的粒度大小、将对象解耦、提高其内聚性</span><br><span class="line">5. 接口隔离原则：要为各个类建立它们需要的专用接口。</span><br><span class="line">   用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。一个类对一个类的依赖应该建立在最小的接口上。</span><br><span class="line"></span><br><span class="line">   建立单一接口，不要建立庞大臃肿的接口尽量细化接口，接口中的方法尽量少，尽量细化接口。注意适度原则，一定要适度。不能滥用</span><br><span class="line"></span><br><span class="line">6. 迪米特法则：只与你的直接朋友交谈,不跟“陌生人&quot;说话。最少知道原则</span><br><span class="line">7. 组合复用原则：尽量先使用组合或者聚合等关联关系来实现,其次才考虑使用继承关系来实现</span><br><span class="line">		先组合，后继承。「包含」关系使用组合，「是」使用继承</span><br></pre></td></tr></table></figure>

<h2 id="switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上？"><a href="#switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上？" class="headerlink" title="switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？"></a>switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？</h2><ul>
<li>switch 可作用于 char byte short int</li>
<li>switch 可作用于 char byte short int 对应的包装类</li>
<li>switch 不可作用于 long double float boolean，以及他们的包装类</li>
</ul>
<h2 id="数组有没有-length-方法？String-有没有-length-方法？"><a href="#数组有没有-length-方法？String-有没有-length-方法？" class="headerlink" title="数组有没有 length () 方法？String 有没有 length () 方法？"></a>数组有没有 length () 方法？String 有没有 length () 方法？</h2><ul>
<li>数组没有 length () 方法，而是 length；</li>
<li>String 有 length () 方法</li>
</ul>
<h2 id="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h2><p>不可以。</p>
<ul>
<li>非 static 方法是要与对象实例息息相关的，必须在创建一个对象后，才可以在该对象上进行非 static 方法调用，而 static 方法跟类相关的，不需要创建对象，可以由类直接调用。</li>
<li>当一个 static 方法被调用时，可能还没有创建任何实例对象，如果从一个 static 方法中发出对非 static 方法的调用，那个非 static 方法是关联到哪个对象上的呢？这个逻辑是不成立的</li>
<li>因此，一个 static 方法内部不可以发出对非 static 方法的调用。</li>
</ul>
<h2 id="String-s-new-String-“jay”-创建了几个字符串对象？"><a href="#String-s-new-String-“jay”-创建了几个字符串对象？" class="headerlink" title="String s &#x3D; new String (“jay”); 创建了几个字符串对象？"></a>String s &#x3D; new String (“jay”); 创建了几个字符串对象？</h2><p>一个或两个</p>
<blockquote>
<ul>
<li>第一次调用 new String (“jay”); 时，会在堆内存中创建一个字符串对象，同时在字符串常量池中创建一个对象 “jay”</li>
<li>第二次调用 new String (“jay”); 时，只会在堆内存中创建一个字符串对象，指向之前在字符串常量池中创建的 “jay”</li>
</ul>
</blockquote>
<p>可以看老王这篇文章，很清晰～<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&mid=2247484162&idx=1&sn=ff743ff5c975a373036749490042a868&chksm=9779472da00ece3b6186d8ce8e79cd1503311327ad4b38f569ccd29a9d15dec065ff201480d2&token=815554431&lang=zh_CN&scene=21#wechat_redirect">别再问我 new 字符串创建了几个对象了！我来证明给你看！</a></p>
<h2 id="this-和-super-关键字的作用"><a href="#this-和-super-关键字的作用" class="headerlink" title="this 和 super 关键字的作用"></a>this 和 super 关键字的作用</h2><p>this：</p>
<ul>
<li>对象内部指代自身的引用</li>
<li>解决成员变量和局部变量同名问题</li>
<li>可以调用成员变量，不能调用局部变量</li>
<li>可以调用成员方法</li>
<li>在普通方法中可以省略 this</li>
<li>在静态方法当中不允许出现 this 关键字</li>
</ul>
<p>super：</p>
<ul>
<li>调用父类 的成员或者方法</li>
<li>调用父类的构造函数</li>
</ul>
<h2 id="我们能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？"><a href="#我们能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？" class="headerlink" title="我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？"></a>我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</h2><p>可以，我们可以做强制转换，但是在 Java 中，int 是 32 位，byte 是 8 位，如果强制做转化，int 类型的高 24 位将会被丢弃。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;    public static void main(String[] args)  &#123;        int a =129;        byte b = (byte) a;        System.out.println(b);        int c =10;        byte d = (byte) c;        System.out.println(d);</span><br><span class="line">    &#125;&#125;输出：-12710</span><br></pre></td></tr></table></figure>

<h2 id="float-f-3-4-正确吗？"><a href="#float-f-3-4-正确吗？" class="headerlink" title="float f&#x3D;3.4; 正确吗？"></a>float f&#x3D;3.4; 正确吗？</h2><p>不正确，精度不准确，应该用强制类型转换<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzFqTyibxYauPWFYQ6d1hDR8Xd2SzGhIpJRmibTApv2UPKibGnofy2mrva5hEg4zh3fsPfyAtURWUzFqQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？"><a href="#接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？" class="headerlink" title="接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？"></a>接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？</h2><p>都可以的</p>
<h2 id="Reader-和-InputStream-区别？"><a href="#Reader-和-InputStream-区别？" class="headerlink" title="Reader 和 InputStream 区别？"></a>Reader 和 InputStream 区别？</h2><ul>
<li>InputStream 是表示字节输入流的所有类的超类</li>
<li>Reader 是用于读取字符流的抽象类</li>
</ul>
<h2 id="列举出-JAVA-中-6-个比较常用的包"><a href="#列举出-JAVA-中-6-个比较常用的包" class="headerlink" title="列举出 JAVA 中 6 个比较常用的包"></a>列举出 JAVA 中 6 个比较常用的包</h2><ul>
<li>java.lang;</li>
<li>java.util;</li>
<li>java.io;</li>
<li>java.sql;</li>
<li>java.awt;</li>
<li>java.net;</li>
</ul>
<h2 id="同步和异步有什么区别？"><a href="#同步和异步有什么区别？" class="headerlink" title="同步和异步有什么区别？"></a>同步和异步有什么区别？</h2><ul>
<li>同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。</li>
<li>异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。</li>
<li>同步，就是实时处理（如打电话）</li>
<li>异步，就是分时处理（如收发短信）</li>
</ul>
<p>参考这篇文章～同步和异步的区别</p>
<h2 id="实际开发中，Java-一般使用什么数据类型来代表价格？"><a href="#实际开发中，Java-一般使用什么数据类型来代表价格？" class="headerlink" title="实际开发中，Java 一般使用什么数据类型来代表价格？"></a>实际开发中，Java 一般使用什么数据类型来代表价格？</h2><p>java 中使用 BigDecimal 来表示价格是比较好的</p>
<p>可以看这篇文章，写得非常好<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247485507&idx=1&sn=5c65f4a62ceab57a23bfe810a161035b&chksm=fddede87caa957918b6c131440c2c7aba5b21d72b296588776c6b85b6f8934bb4b6bfda97858&token=815554431&lang=zh_CN&scene=21#wechat_redirect">老大说：谁要再用 double 定义商品金额，就自己收拾东西走</a></p>
<h2 id="64-位-JVM-中，int-的长度是多数？"><a href="#64-位-JVM-中，int-的长度是多数？" class="headerlink" title="64 位 JVM 中，int 的长度是多数？"></a>64 位 JVM 中，int 的长度是多数？</h2><p>int 数据类型占 4 个字节 32 位，跟 JVM 位数没关系的</p>
<h2 id="Lombok-中-Data-相当于哪几个注解"><a href="#Lombok-中-Data-相当于哪几个注解" class="headerlink" title="Lombok 中 @Data 相当于哪几个注解"></a>Lombok 中 @Data 相当于哪几个注解</h2><p>@Data 最常用的注解之一。注解在类上，提供该类所有属性的 getter&#x2F;setter 方法，还提供了 equals、canEqual、hashCode、toString 方法</p>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p><strong>分库分表是为了解决由于库、表数据量过大，而导致数据库性能持续下降的问题。</strong></p>
<p>常见的分库分表工具&#x2F;中间件有：<code>sharding-jdbc</code>（当当）、<code>TSharding</code>（蘑菇街）、<code>MyCAT</code>（基于 Cobar）、<code>Cobar</code>（阿里巴巴）……</p>
<p><strong>推荐使用 <code>sharding-jdbc</code></strong> 。 因为 <code>sharding-jdbc</code> 是一款轻量级 <code>Java</code> 框架，以 <code>jar</code> 包形式提供服务，不要我们做额外的运维工作，并且兼容性也很好。</p>
<p><a target="_blank" rel="noopener" href="https://veal98.gitee.io/cs-wiki/#/README?id=%e2%91%a3-%e5%88%86%e5%ba%93%e5%88%86%e8%a1%a8">https://veal98.gitee.io/cs-wiki/#/README?id=%e2%91%a3-%e5%88%86%e5%ba%93%e5%88%86%e8%a1%a8</a></p>
<h2 id="集群、分布式、负载均衡的区别"><a href="#集群、分布式、负载均衡的区别" class="headerlink" title="集群、分布式、负载均衡的区别"></a><a target="_blank" rel="noopener" href="https://veal98.gitee.io/cs-wiki/#/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/2-%E9%9B%86%E7%BE%A4+%E5%88%86%E5%B8%83%E5%BC%8F+%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%8C%BA%E5%88%AB?id=%F0%9F%8C%90-%E9%9B%86%E7%BE%A4%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%8C%BA%E5%88%AB">集群、分布式、负载均衡的区别</a></h2><h2 id="负载均衡算法与实现负载均衡的技术"><a href="#负载均衡算法与实现负载均衡的技术" class="headerlink" title="负载均衡算法与实现负载均衡的技术"></a><a target="_blank" rel="noopener" href="https://veal98.gitee.io/cs-wiki/#/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E6%8A%80%E6%9C%AF?id=%F0%9F%92%BB-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E6%8A%80%E6%9C%AF">负载均衡算法与实现负载均衡的技术</a></h2><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><ul>
<li><p>读写分离主要是为了将数据库的读和写操作分布到不同的数据库节点上。<strong>主服务器负责写，从服务器负责读</strong>。一主一从或者一主多从都可以</p>
</li>
<li><p>读写分离可以大幅提高读性能，小幅提高写的性能。因此，<strong>读写分离更适合单机并发读请求比较多的场景</strong>。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://veal98.gitee.io/cs-wiki/#/README?id=%e2%91%a2-%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb">https://veal98.gitee.io/cs-wiki/#/README?id=%e2%91%a2-%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wangwenzhe.github.io">王文哲</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wangwenzhe.github.io/posts/c5d24821.html">https://wangwenzhe.github.io/posts/c5d24821.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wangwenzhe.github.io" target="_blank">王文哲的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"><div class="social-share" data-image="/about/logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/c5d24821.html" title="Java-面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java-面试题</div></div></a></div><div class="next-post pull-right"><a href="/posts/3dbe92fd.html" title="DM-Docker"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">DM-Docker</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/56e94e1f.html" title="面试题-网络协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-06</div><div class="title">面试题-网络协议</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/about/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">王文哲</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">593</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">354</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">555</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">风雨无阻，灯火为你，星光虽微，照耀夜空。</div></div><div class="card-widget card-cheesy_pick-up_lines"><div class="card-content"><div class="item-headline"><i class="fas fa-heart" style="color:pink"></i><span>想对你说</span></div><div id="cheesy_pick-up_lines-container"></div></div></div><script data-pjax="data-pjax" src="/js/cheesy_pick-up_lines.js"></script><div class="js-pjax"><script>cheesy_pick_up_lines()</script></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A5%E6%BA%90"><span class="toc-number">1.</span> <span class="toc-text">来源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#equals-%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">equals 与 &#x3D;&#x3D; 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final-finally-finalize-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">final, finally, finalize 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">重载和重写的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84-hashCode-%E7%9B%B8%E5%90%8C%EF%BC%8C%E5%88%99-equals-%E6%98%AF%E5%90%A6%E4%B9%9F%E4%B8%80%E5%AE%9A%E4%B8%BA-true%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">两个对象的 hashCode () 相同，则 equals () 是否也一定为 true？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">抽象类和接口有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIO%E3%80%81NIO%E3%80%81AIO-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">BIO、NIO、AIO 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%EF%BC%8CStringbuffer%EF%BC%8CStringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%8C%E8%80%83%E3%80%8D"><span class="toc-number">8.</span> <span class="toc-text">String，Stringbuffer，StringBuilder 的区别「考」</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA-%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%90%84%E8%87%AA%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%E5%91%A2"><span class="toc-number">9.</span> <span class="toc-text">JAVA 中的几种基本数据类型是什么，各自占用多少字节呢</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Comparator-%E4%B8%8E-Comparable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">Comparator 与 Comparable 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E7%B1%BB%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E3%80%82"><span class="toc-number">11.</span> <span class="toc-text">String 类能被继承吗，为什么。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Java-%E4%B8%AD%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">12.</span> <span class="toc-text">说说 Java 中多态的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">13.</span> <span class="toc-text">Java 泛型和类型擦除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#int-%E5%92%8C-Integer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E8%BF%98%E6%9C%89-Integer-%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">14.</span> <span class="toc-text">int 和 Integer 有什么区别，还有 Integer 缓存的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%8F%8D%E5%B0%84%E7%9A%84%E7%94%A8%E9%80%94%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8CJava-%E8%8E%B7%E5%8F%96%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">15.</span> <span class="toc-text">说说反射的用途及实现原理，Java 获取反射的三种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">16.</span> <span class="toc-text">面向对象的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">17.</span> <span class="toc-text">&amp; 和 &amp;&amp; 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD-IO-%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">Java 中 IO 流分为几种？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%EF%BC%8C%E6%AF%94%E5%A6%82%E7%88%B6%E7%B1%BB%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AD%90%E7%B1%BB%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">19.</span> <span class="toc-text">讲讲类的实例化顺序，比如父类静态数据，构造函数，子类静态数据，构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">20.</span> <span class="toc-text">Java 创建对象有几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86-GB2312-%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA-ISO-8859-1-%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%91%A2%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">如何将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">22.</span> <span class="toc-text">守护线程是什么？用什么方法实现守护线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#notify-%E5%92%8C-notifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">notify () 和 notifyAll () 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E8%AF%AD%E8%A8%80%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%EF%BC%8C%E5%85%B3%E9%94%AE%E5%AD%97-throws%E3%80%81throw%E3%80%81try%E3%80%81catch%E3%80%81finally-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">Java 语言是如何处理异常的，关键字 throws、throw、try、catch、finally 怎么使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-Java-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">25.</span> <span class="toc-text">谈谈 Java 的异常层次结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">26.</span> <span class="toc-text">静态内部类与非静态内部类有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-s-%E4%B8%8E-new-String-%E4%B8%8E%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">27.</span> <span class="toc-text">String s 与 new String 与有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%B8%AD%EF%BC%8CClass-forName-%E5%92%8C-ClassLoader-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">28.</span> <span class="toc-text">反射中，Class.forName 和 ClassLoader 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E-cglib-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">29.</span> <span class="toc-text">JDK 动态代理与 cglib 实现的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#error-%E5%92%8C-exception-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8CCheckedException%EF%BC%8CRuntimeException-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">30.</span> <span class="toc-text">error 和 exception 的区别，CheckedException，RuntimeException 的区别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB"><span class="toc-number">31.</span> <span class="toc-text">深拷贝和浅拷贝区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-%E5%92%8C-JRE-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">JDK 和 JRE 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%E5%91%A2%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">String 类的常用方法都有那些呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">34.</span> <span class="toc-text">谈谈自定义注解的场景及实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%86%9F%E6%82%89%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">35.</span> <span class="toc-text">说说你熟悉的设计模式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E5%92%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">抽象工厂和工厂方法模式的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-number">37.</span> <span class="toc-text">什么是值传递和引用传递？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E5%9C%A8-static-%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%AE%BF%E9%97%AE%E9%9D%9E-static-%E5%8F%98%E9%87%8F%E5%90%97%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">可以在 static 环境中访问非 static 变量吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">39.</span> <span class="toc-text">Java 支持多继承么，为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%97-2-%E4%B9%98%E4%BB%A5-8%EF%BC%9F"><span class="toc-number">40.</span> <span class="toc-text">用最有效率的方法计算 2 乘以 8？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F"><span class="toc-number">41.</span> <span class="toc-text">构造器是否可被重写？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#char-%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AD%98%E8%B4%AE%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">42.</span> <span class="toc-text">char 型变量中能不能存贮一个中文汉字，为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">如何实现对象克隆？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object-%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">44.</span> <span class="toc-text">object 中定义了哪些方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashCode-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">45.</span> <span class="toc-text">hashCode 的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-each-%E4%B8%8E%E5%B8%B8%E8%A7%84-for-%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94"><span class="toc-number">46.</span> <span class="toc-text">for-each 与常规 for 循环的效率对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%87%BA%E5%87%A0%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB"><span class="toc-number">47.</span> <span class="toc-text">写出几种单例模式实现，懒汉模式和饿汉模式区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E5%88%97%E5%87%BA-5-%E4%B8%AA%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">48.</span> <span class="toc-text">请列出 5 个运行时异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%AA%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%8F%AF%E8%83%BD%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84-hashcode-%E5%90%97%EF%BC%9F"><span class="toc-number">49.</span> <span class="toc-text">2 个不相等的对象有可能具有相同的 hashcode 吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-public-private-protected-%E4%BB%A5%E5%8F%8A-default-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">50.</span> <span class="toc-text">访问修饰符 public,private,protected, 以及 default 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-final-%E5%9C%A8-java-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">51.</span> <span class="toc-text">谈谈 final 在 java 中的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E4%B8%AD%E7%9A%84-Math-round-1-5-%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91%E5%91%A2%EF%BC%9F"><span class="toc-number">52.</span> <span class="toc-text">java 中的 Math.round (-1.5) 等于多少呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E5%B1%9E%E4%BA%8E%E5%9F%BA%E7%A1%80%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F"><span class="toc-number">53.</span> <span class="toc-text">String 属于基础的数据类型吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%E5%91%A2%EF%BC%9F"><span class="toc-number">54.</span> <span class="toc-text">如何将字符串反转呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AE%83%E4%BB%AC%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">55.</span> <span class="toc-text">描述动态代理的几种实现方式，它们分别有什么优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-java-lang-String-%E7%B1%BB%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">56.</span> <span class="toc-text">在自己的代码中，如果创建一个 java.lang.String 类，这个类是否可以被类加载器加载？为什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-java-lang-Object-%E5%AF%B9%E8%B1%A1%E4%B8%AD-hashCode-%E5%92%8C-equals-%E6%96%B9%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-number">57.</span> <span class="toc-text">谈谈你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需要重新实现这两个方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-jdk1-5-%E4%B8%AD%EF%BC%8C%E5%BC%95%E5%85%A5%E4%BA%86%E6%B3%9B%E5%9E%8B%EF%BC%8C%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AD%98%E5%9C%A8%E6%98%AF%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">58.</span> <span class="toc-text">在 jdk1.5 中，引入了泛型，泛型的存在是用来解决什么问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E6%80%8E%E4%B9%88%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%91%A2%EF%BC%9F"><span class="toc-number">59.</span> <span class="toc-text">什么是序列化，怎么序列化，反序列呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java8-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">60.</span> <span class="toc-text">java8 的新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%9C%A8%E5%85%B6%E5%A4%96%E9%9D%A2%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8F%98%E9%87%8F%E5%91%A2%EF%BC%9F"><span class="toc-number">61.</span> <span class="toc-text">匿名内部类是什么？如何访问在其外面定义的变量呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break-%E5%92%8C-continue-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">62.</span> <span class="toc-text">break 和 continue 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-s-%E2%80%9CHello%E2%80%9D-s-s-%E2%80%9Cworld-%E2%80%9D-%E8%BF%99%E4%B8%A4%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%90%8E%EF%BC%8C%E5%8E%9F%E5%A7%8B%E7%9A%84-String-%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%AF%E5%90%A6%E4%BC%9A%E6%94%B9%E5%8F%98%EF%BC%9F"><span class="toc-number">63.</span> <span class="toc-text">String s &#x3D; “Hello”;s &#x3D; s + “world!”; 这两行代码执行后，原始的 String 对象中的内容是否会改变？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-s-%E2%80%9Ca%E2%80%9D-%E2%80%9Db%E2%80%9D-%E2%80%9Dc%E2%80%9D-%E2%80%9Dd%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">64.</span> <span class="toc-text">String s &#x3D; “a”+”b”+”c”+”d”; 创建了几个对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-catch-finally-return-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">65.</span> <span class="toc-text">try-catch-finally-return 执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E2%80%9D-%E5%85%AD%E5%8E%9F%E5%88%99%E4%B8%80%E6%B3%95%E5%88%99%E2%80%9D%E3%80%82"><span class="toc-number">66.</span> <span class="toc-text">简述一下面向对象的” 六原则一法则”。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch-%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8-byte-%E4%B8%8A%EF%BC%8C%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8-long-%E4%B8%8A%EF%BC%8C%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8-String-%E4%B8%8A%EF%BC%9F"><span class="toc-number">67.</span> <span class="toc-text">switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%9C%89%E6%B2%A1%E6%9C%89-length-%E6%96%B9%E6%B3%95%EF%BC%9FString-%E6%9C%89%E6%B2%A1%E6%9C%89-length-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">68.</span> <span class="toc-text">数组有没有 length () 方法？String 有没有 length () 方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%EF%BC%88static%EF%BC%89%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E5%8F%91%E5%87%BA%E5%AF%B9%E9%9D%9E%E9%9D%99%E6%80%81%EF%BC%88non-static%EF%BC%89%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">69.</span> <span class="toc-text">是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-s-new-String-%E2%80%9Cjay%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">70.</span> <span class="toc-text">String s &#x3D; new String (“jay”); 创建了几个字符串对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this-%E5%92%8C-super-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">71.</span> <span class="toc-text">this 和 super 关键字的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E8%83%BD%E5%B0%86-int-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA-byte-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%AF%A5%E5%80%BC%E5%A4%A7%E4%BA%8E-byte-%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%8C%E5%B0%86%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E7%8E%B0%E8%B1%A1%EF%BC%9F"><span class="toc-number">72.</span> <span class="toc-text">我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#float-f-3-4-%E6%AD%A3%E7%A1%AE%E5%90%97%EF%BC%9F"><span class="toc-number">73.</span> <span class="toc-text">float f&#x3D;3.4; 正确吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%8F%AF%E5%90%A6%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E5%AE%9E%E4%BD%93%E7%B1%BB%EF%BC%9F"><span class="toc-number">74.</span> <span class="toc-text">接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reader-%E5%92%8C-InputStream-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">75.</span> <span class="toc-text">Reader 和 InputStream 区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E4%B8%BE%E5%87%BA-JAVA-%E4%B8%AD-6-%E4%B8%AA%E6%AF%94%E8%BE%83%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85"><span class="toc-number">76.</span> <span class="toc-text">列举出 JAVA 中 6 个比较常用的包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">77.</span> <span class="toc-text">同步和异步有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8CJava-%E4%B8%80%E8%88%AC%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9D%A5%E4%BB%A3%E8%A1%A8%E4%BB%B7%E6%A0%BC%EF%BC%9F"><span class="toc-number">78.</span> <span class="toc-text">实际开发中，Java 一般使用什么数据类型来代表价格？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E4%BD%8D-JVM-%E4%B8%AD%EF%BC%8Cint-%E7%9A%84%E9%95%BF%E5%BA%A6%E6%98%AF%E5%A4%9A%E6%95%B0%EF%BC%9F"><span class="toc-number">79.</span> <span class="toc-text">64 位 JVM 中，int 的长度是多数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lombok-%E4%B8%AD-Data-%E7%9B%B8%E5%BD%93%E4%BA%8E%E5%93%AA%E5%87%A0%E4%B8%AA%E6%B3%A8%E8%A7%A3"><span class="toc-number">80.</span> <span class="toc-text">Lombok 中 @Data 相当于哪几个注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">81.</span> <span class="toc-text">分库分表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">82.</span> <span class="toc-text">集群、分布式、负载均衡的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E6%8A%80%E6%9C%AF"><span class="toc-number">83.</span> <span class="toc-text">负载均衡算法与实现负载均衡的技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">84.</span> <span class="toc-text">读写分离</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1e40bac5.html" title="Java-JUC-Executors">Java-JUC-Executors</a><time datetime="2025-06-18T09:27:58.000Z" title="发表于 2025-06-18 17:27:58">2025-06-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/a48b71a9.html" title="Java-负载均衡策略-最小连接">Java-负载均衡策略-最小连接</a><time datetime="2025-06-18T06:49:05.000Z" title="发表于 2025-06-18 14:49:05">2025-06-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/429b593d.html" title="Redis-用户签到方案">Redis-用户签到方案</a><time datetime="2025-06-17T09:55:08.000Z" title="发表于 2025-06-17 17:55:08">2025-06-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/e8154c21.html" title="开发规范-Git分支管理">开发规范-Git分支管理</a><time datetime="2025-06-17T06:56:23.000Z" title="发表于 2025-06-17 14:56:23">2025-06-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/cf577558.html" title="开发规范-前端">开发规范-前端</a><time datetime="2025-06-17T06:55:55.000Z" title="发表于 2025-06-17 14:55:55">2025-06-17</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 王文哲</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="/js/fishes.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start -->
      <div id="xf-MusicPlayer" data-cdnName="https://player.xfyun.club/js"  data-themeColor="xf-darkGreen"data-memory="1"></div>
<script src="https://player.xfyun.club/js/xf-MusicPlayer/js/xf-MusicPlayer.min.js"></script><!-- hexo injector body_end end --></body></html>